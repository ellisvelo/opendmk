/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*//*
 * @(#)file      Parser.jj
 * @(#)author    Sun Microsystems, Inc.
 * @(#)version   4.12
 * @(#)date      07/10/01
 *
 * 
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 * 
 * Copyright (c) 2007 Sun Microsystems, Inc. All Rights Reserved.
 * 
 * The contents of this file are subject to the terms of either the GNU General
 * Public License Version 2 only ("GPL") or the Common Development and
 * Distribution License("CDDL")(collectively, the "License"). You may not use
 * this file except in compliance with the License. You can obtain a copy of the
 * License at http://opendmk.dev.java.net/legal_notices/licenses.txt or in the 
 * LEGAL_NOTICES folder that accompanied this code. See the License for the 
 * specific language governing permissions and limitations under the License.
 * 
 * When distributing the software, include this License Header Notice in each
 * file and include the License file found at
 *     http://opendmk.dev.java.net/legal_notices/licenses.txt
 * or in the LEGAL_NOTICES folder that accompanied this code.
 * Sun designates this particular file as subject to the "Classpath" exception
 * as provided by Sun in the GPL Version 2 section of the License file that
 * accompanied this code.
 * 
 * If applicable, add the following below the License Header, with the fields
 * enclosed by brackets [] replaced by your own identifying information:
 * 
 *       "Portions Copyrighted [year] [name of copyright owner]"
 * 
 * Contributor(s):
 * 
 * If you wish your version of this file to be governed by only the CDDL or
 * only the GPL Version 2, indicate your decision by adding
 * 
 *       "[Contributor] elects to include this software in this distribution
 *        under the [CDDL or GPL Version 2] license."
 * 
 * If you don't indicate a single choice of license, a recipient has the option
 * to distribute your version of this file under either the CDDL or the GPL
 * Version 2, or to extend the choice of license to its licensees as provided
 * above. However, if you add GPL Version 2 code and therefore, elected the
 * GPL Version 2 license, then the option applies only if the new code is made
 * subject to such option by the copyright holder.
 * 
 *
 */

options {              
  STATIC=false;                                            
}


PARSER_BEGIN(Parser)

package com.sun.jdmk.tools.mibgen;


import java.io.*;
import java.math.*;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/
protected boolean snmpV2= false;
static BigInteger max64= new BigInteger("18446744073709551615");
}

PARSER_END(Parser)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>

}



/* RESERVED WORDS AND LITERALS */

TOKEN : 
{
 <ACCESS: "ACCESS">
| <AFN: "accessible-for-notify">
| <AGENT: "AGENT-CAPABILITIES">
| <APPLICATION: "APPLICATION">
| <ASSIGN: "::=">
| <AUGMENTS: "AUGMENTS">
| <BEGIN: "BEGIN">
| <BIT: "BIT">
| <BITS: "BITS">
| <CHOICE: "CHOICE">
| <CONTACT: "CONTACT-INFO">
| <CURRENT: "current">
| <DEFINITIONS: "DEFINITIONS" >
| <DEFVAL: "DEFVAL" >
| <DEPRECATED: "deprecated">
| <DESCRIPTION: "DESCRIPTION">
| <DISPLAY: "DISPLAY-HINT">
| <EMPTY: "empty">
| <END: "END">
| <ENTERPRISE: "ENTERPRISE">
| <EXPLICIT: "EXPLICIT">
| <EXPORTS: "EXPORTS">
| <FALSE: "FALSE">
| <FROM: "FROM">
| <GROUP: "GROUP">
| <IDENT: "IDENTIFIER">
| <ID: "identifier">
| <IMPLICIT: "IMPLICIT">
| <IMPLIED: "IMPLIED">
| <IMPORTS: "IMPORTS">
| <INDEX: "INDEX">
| <INTEGER: "INTEGER">
| <LASTUPDATE: "LAST-UPDATED">
| <MACRO: "MACRO">
| <MANDATGROUPS: "MANDATORY-GROUPS">
| <MANDATORY: "mandatory">
| <MAXACCESS: "MAX-ACCESS">
| <MIN_ACCESS: "MIN-ACCESS">
| <MODULE: "MODULE">
| <MODULE_COMPLIANCE: "MODULE-COMPLIANCE">
| <MODULE_IDENTITY: "MODULE-IDENTITY">
| <NA: "not-accessible">
| <NOTATION: "NOTATION">
| <NOTIFICATIONS: "NOTIFICATIONS">
| <NOTIFICATION_GROUP: "NOTIFICATION-GROUP">
| <NOTIFICATION_TYPE: "NOTIFICATION-TYPE">
| <NULL: "NULL">
| <NUMBER: "number">
| <OBJECT: "OBJECT">
| <OBJECTS: "OBJECTS">
| <OBJECT_IDENTITY: "OBJECT-IDENTITY">
| <OBJECT_GROUP: "OBJECT-GROUP">
| <OBJECT_TYPE: "OBJECT-TYPE">
| <OBSOLETE: "obsolete">
| <OCTET: "OCTET">
| <OF: "OF">
| <OPTIONAL: "optional">
| <ORG: "ORGANIZATION">
| <REFERENCE: "REFERENCE">
| <REVISION: "REVISION">
| <RC: "read-create">
| <RO: "read-only">
| <RW: "read-write">
| <SEQUENCE: "SEQUENCE">
| <SIZE: "SIZE">
| <STATUS: "STATUS">
| <STR: "string">
| <STRING: "STRING">
| <SYNTAX: "SYNTAX">
| <TEXTUAL_CONVENTION: "TEXTUAL-CONVENTION">
| <TRAP_TYPE: "TRAP-TYPE">
| <TRUE: "TRUE">
| <TYPE: "TYPE">
| <TYPE_MACRO: "type">
| <UNITS: "UNITS">
| <UNIVERSAL: "UNIVERSAL">
| <VAL: "value">
| <VALUE: "VALUE">
| <VARIABLES: "VARIABLES">
| <WO: "write-only">
| <WRITE_SYNTAX: "WRITE-SYNTAX">
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: ["a"-"z"] (<LETTER>|<DIGIT>)* >
|
  < TYPEREFERENCE: ["A"-"Z"] (<LETTER>|<DIGIT>)* >
|
  < #LETTER: ["_","-","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
}

TOKEN : /* VALUES */
{
  < INTEGER_LITERAL: ["0"-"9"] (["0"-"9"])* >
|
  <NEGATIVE_INTEGER: "-" <INTEGER_LITERAL> >
|
  <BSTRING: "'" (["0"-"1"])* ("'B"|"'b")>
|
  <HSTRING: "'"(["0"-"9","A"-"F", "a"-"f"])* ("'H"|"'h")>
|
  <CSTRING: "\"" (~["\""])* "\"">
}
 

TOKEN: /* SEPARATOR */
{
  < SEMICOLON: ";" >
| < COMMA: "," >
| < RANGE: "..">
}

// A file can contain several different modules
//
ASTMibs Mibs(ModulesHandler handler) throws SemanticException : {/*@bgen(jjtree) Mibs */
  ASTMibs jjtn000 = new ASTMibs(JJTMIBS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Mibs */
  try {
/*@egen*/
  (Mib(handler))+/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    if (jjte000 instanceof SemanticException) {
      throw (SemanticException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
  
}

// Definition of a MIB. Identical to an ASN.1 module
//
void Mib(ModulesHandler handler) throws SemanticException: {/*@bgen(jjtree) Mib */
  ASTMib jjtn000 = new ASTMib(JJTMIB);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Mib */
  try {
/*@egen*/
  jjtn000.moduleIdentifier= ModuleIdentifier() 
  "DEFINITIONS" "::=" "BEGIN" ModuleBody(jjtn000) "END"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
     // Register the mib !
     //
     handler.addMibModule(jjtn000.moduleIdentifier.getModuleName(), jjtn000);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    if (jjte000 instanceof SemanticException) {
      throw (SemanticException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// Definition of a module identifier. Can contain an oid ...
//
ASTModuleIdentifier ModuleIdentifier(): 
{/*@bgen(jjtree) ModuleIdentifier */
  ASTModuleIdentifier jjtn000 = new ASTModuleIdentifier(JJTMODULEIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) ModuleIdentifier */
   try {
/*@egen*/
   t= <TYPEREFERENCE> [OidValue()]/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { 
     jjtn000.moduleName= t.image;
     if (jjtn000.moduleName.equals("SNMPv2-SMI")) {
	snmpV2= true;
     }
     return jjtn000; 
   }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

// Definition of a ModuleBody. 
//
void ModuleBody(ASTMib myMib)  throws SemanticException: {/*@bgen(jjtree) ModuleBody */
  ASTModuleBody jjtn000 = new ASTModuleBody(JJTMODULEBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ModuleBody */
try {
/*@egen*/
[Exports()] [Imports()] (Assignment(myMib))*/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  if (jjte000 instanceof SemanticException) {
    throw (SemanticException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/ 
}

void Assignment(ASTMib myMib) throws SemanticException : {/*@bgen(jjtree) Assignment */
  ASTAssignment jjtn000 = new ASTAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) Assignment */
try {
/*@egen*/
( jjtn000.symbolName= Identifier() 
  ( 
    ValueDefinition(myMib, jjtn000.symbolName) 
  | 
    ObjectTypeDefinition(myMib, jjtn000.symbolName)
  |
    ModuleIdentity(myMib, jjtn000.symbolName)
  |  
    ModuleCompliance()
  |  
    AgentCapabilities()
  |
    ObjectIdentity(myMib, jjtn000.symbolName)
  |
    TrapType()
  | 
    NotificationType(myMib, jjtn000.symbolName)
  |
    ObjectGroup(myMib, jjtn000.symbolName)
  |
    NotificationGroup(myMib, jjtn000.symbolName)
  )
) 
|
  LOOKAHEAD(<TYPEREFERENCE> "::=" "TEXTUAL-CONVENTION")
  TextualConvention(myMib)
|
  LOOKAHEAD(<TYPEREFERENCE> "::=")
  SyntaxDefinition(myMib)
| 
  MacroDefinition()/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}


void SyntaxDefinition(ASTMib myMib): {/*@bgen(jjtree) SyntaxDefinition */
  ASTSyntaxDefinition jjtn000 = new ASTSyntaxDefinition(JJTSYNTAXDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) SyntaxDefinition */
  try {
/*@egen*/
  jjtn000.symbolName=TypeReference() "::=" jjtn000.type=NamedType()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ 
  { 
    myMib.registerSyntaxDef(jjtn000.symbolName, jjtn000);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// At the moment only accept types supported by the different SNMP SMI.
// 
ASTNamedType NamedType(): {/*@bgen(jjtree) NamedType */
  ASTNamedType jjtn000 = new ASTNamedType(JJTNAMEDTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NamedType */
try {
/*@egen*/
Type()/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{ return jjtn000; }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}



void ObjectTypeDefinition(ASTMib myMib, String symbolName): {/*@bgen(jjtree) ObjectTypeDefinition */
  ASTObjectTypeDefinition jjtn000 = new ASTObjectTypeDefinition(JJTOBJECTTYPEDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ObjectTypeDefinition */
  try {
/*@egen*/
  "OBJECT-TYPE" "SYNTAX" jjtn000.syntax= NamedType()

// Be really cool ... Allow to mix V1 and V2 definitions...
//
(  jjtn000.def= ObjectTypeDefinitionV2()/*@bgen(jjtree)*/
                                         {
                                           jjtree.closeNodeScope(jjtn000, true);
                                           jjtc000 = false;
                                         }
/*@egen*/ { myMib.registerV2ObjectType(symbolName,jjtn000); }
| 
  jjtn000.def= ObjectTypeDefinitionV1()/*@bgen(jjtree)*/
                                        {
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                        }
/*@egen*/ { myMib.registerV1ObjectType(symbolName,jjtn000); }
)/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
   
}

// Start Handling of values.
//

// The identifier is read in the previous rule (Assignment)
//
void ValueDefinition(ASTMib myMib, String symbolName): {/*@bgen(jjtree) ValueDefinition */
  ASTValueDefinition jjtn000 = new ASTValueDefinition(JJTVALUEDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ValueDefinition */
try {
/*@egen*/
Type() "::=" Value()/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ { myMib.registerValueDef(symbolName,jjtn000); }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

// Handle list of exports. Somewhere in one of the RFC it says that
// export should not be used. We never know ...
//
void Exports() :
{/*@bgen(jjtree) Exports */
  ASTExports jjtn000 = new ASTExports(JJTEXPORTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
} 
{/*@bgen(jjtree) Exports */
try {
/*@egen*/
t="EXPORTS" {
    // Get the line number ...
    //
    int lineNb= t.beginLine;
    Integer val= new Integer(lineNb);
    Trace.warning(MessageHandler.getMessage("compile.w.export",val));
  }
(SymbolsList()) ";"/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void Imports() : {/*@bgen(jjtree) Imports */
  ASTImports jjtn000 = new ASTImports(JJTIMPORTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) Imports */
try {
/*@egen*/
"IMPORTS" (SymbolsImported()) ";"/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void SymbolsImported(): {/*@bgen(jjtree) SymbolsImported */
  ASTSymbolsImported jjtn000 = new ASTSymbolsImported(JJTSYMBOLSIMPORTED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SymbolsImported */
try {
/*@egen*/
(SymbolsList() "FROM" ModuleIdentifier())*/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}


void SymbolsList(): {/*@bgen(jjtree) SymbolsList */
  ASTSymbolsList jjtn000 = new ASTSymbolsList(JJTSYMBOLSLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SymbolsList */
 try {
/*@egen*/
 (Identifier()| TypeReference() | Reserved()) ("," (Identifier()|TypeReference()| Reserved()))*/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}



void Type(): {/*@bgen(jjtree) Type */
  ASTType jjtn000 = new ASTType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Type */
try {
/*@egen*/
[jjtn000.tag=Tag()] BuiltinType()| DefinedType()/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void BuiltinType(): {/*@bgen(jjtree) BuiltinType */
  ASTBuiltinType jjtn000 = new ASTBuiltinType(JJTBUILTINTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) BuiltinType */
  try {
/*@egen*/

  "INTEGER" {jjtn000.type= INTEGER;} (IntSubType())?
|
  "OCTET" "STRING" {jjtn000.type= OCTET;} (SubType())?
|
  "OBJECT" "IDENTIFIER"/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ {jjtn000.type= OBJECT;}
|
  "BIT" "STRING" {jjtn000.type=BIT;}  [NamedBitList()]
|
  "BITS" {jjtn000.type=BIT;}  [NamedBitList()]
|
  "NULL"/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/ {jjtn000.type= NULL;}
|
 "SEQUENCE" {jjtn000.type= SEQUENCE;} SequenceType()
|
 "CHOICE" {jjtn000.type= CHOICE;} ChoiceType()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTTag Tag(): 
{/*@bgen(jjtree) Tag */
  ASTTag jjtn000 = new ASTTag(JJTTAG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Tag */
try {
/*@egen*/
"[" [ "UNIVERSAL" { jjtn000.classType= UNIVERSAL; }
      |
      "APPLICATION" { jjtn000.classType= APPLICATION;}

      // Do not need to support PRIVATE for SNMP vX
    ]
jjtn000.classNumber= IntegerValue()

"]"

[
  "IMPLICIT" { jjtn000.implicit= true; }
  |
  "EXPLICIT" {jjtn000.implicit= false;}
]/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/

{return jjtn000;}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void SubType(): {/*@bgen(jjtree) SubType */
  ASTSubType jjtn000 = new ASTSubType(JJTSUBTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) SubType */
try {
/*@egen*/
"(" 
  (
    "SIZE" "(" Range()  ("|" Range())* ")" 
  |
    Range()
  )
")"/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void SequenceType(): {/*@bgen(jjtree) SequenceType */
  ASTSequenceType jjtn000 = new ASTSequenceType(JJTSEQUENCETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) SequenceType */
try {
/*@egen*/
"{" [Identifier()] Type() ( "," [Identifier()] Type())* "}"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {jjtn000.type= SEQUENCE;}
|
"OF" { jjtn000.type= OF;}  Type()/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void ChoiceType(): {/*@bgen(jjtree) ChoiceType */
  ASTChoiceType jjtn000 = new ASTChoiceType(JJTCHOICETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ChoiceType */
try {
/*@egen*/
"{" [Identifier()] Type() ( "," [Identifier()] Type())* "}"/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

// Support only the kibble form i.e identifier(nonNegativeNumber) !
//
void NamedBitList(): {/*@bgen(jjtree) NamedBitList */
  ASTNamedBitList jjtn000 = new ASTNamedBitList(JJTNAMEDBITLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) NamedBitList */
 try {
/*@egen*/
 "{" Kibble(jjtn000) ("," Kibble(jjtn000))* "}"/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

void Kibble(ASTNamedBitList sup): 
{/*@bgen(jjtree) Kibble */
ASTKibble jjtn000 = new ASTKibble(JJTKIBBLE);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
Token t;
}
{/*@bgen(jjtree) Kibble */
try {
/*@egen*/
jjtn000.name= Identifier() "(" t=<INTEGER_LITERAL> 
  {  
    jjtn000.value= Integer.parseInt(t.image);
    // Add the enum into the hashtable ...
    //
    sup.addEnumDef(jjtn000.name, new String(t.image.trim()));
  }  ")"/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}


// When dealing with an INTEGER, we can have a enum
// or a size restriction.
void IntSubType(): {/*@bgen(jjtree) IntSubType */
  ASTIntSubType jjtn000 = new ASTIntSubType(JJTINTSUBTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IntSubType */
try {
/*@egen*/
"{" Enum(jjtn000) ("," Enum(jjtn000))* "}"
|
"(" Range() ("|" Range())* ")"/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void Range():
{/*@bgen(jjtree) Range */
  ASTRange jjtn000 = new ASTRange(JJTRANGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ 
  Token t;
}
{/*@bgen(jjtree) Range */
  try {
/*@egen*/
  jjtn000.low= RangeValue() 
[
  t=".." jjtn000.high=RangeValue()
  { 
    if (jjtn000.low > jjtn000.high) {
      // Get the line number ...
      //
      int lineNb= t.beginLine;
      Integer val= new Integer(lineNb);
      Trace.warning(MessageHandler.getMessage("compile.w.range",val));
    } 
  }
// |
// ("|" jjtThis.low= IntegerValue())+

]/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

long RangeValue() : 
{/*@bgen(jjtree) RangeValue */
  ASTRangeValue jjtn000 = new ASTRangeValue(JJTRANGEVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) RangeValue */
  try {
/*@egen*/
  t=<BSTRING>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
    try {
      int length= t.image.length();
      if (length >=3) {
         String val= t.image.toLowerCase();
         val= val.substring(0, val.lastIndexOf("b"));
         val= val.replace('\'', ' ').trim();
         jjtn000.val=  (long) Integer.parseInt(val, 2);
      } else {
        jjtn000.val=0;
      }
    } catch(java.lang.NumberFormatException e) {
      int lineNb= t.beginLine;
      Integer val= new Integer(lineNb);
      Trace.warning(MessageHandler.getMessage("compile.w.value",t.image, val));
      jjtn000.val=0;
    }
    return jjtn000.val;
    }
|
  t=<HSTRING>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
    try {
      int length= t.image.length();
      if (length >=3) {
         String val= t.image.toLowerCase();
         val= val.substring(0, val.lastIndexOf("h"));
         val= val.replace('\'', ' ').trim();
         if (val.length() > 8) 
            throw new NumberFormatException();
         jjtn000.val=  (long) Long.parseLong(val, 16);
      } else {
        jjtn000.val=0;
      }
    } catch(java.lang.NumberFormatException e) {
      int lineNb= t.beginLine;
      Integer val= new Integer(lineNb);
      Trace.warning(MessageHandler.getMessage("compile.w.value",t.image, val));
      jjtn000.val=0;
    }
    return jjtn000.val;
    }
|
 t= <INTEGER_LITERAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
    try {
      jjtn000.val=  (long) Long.parseLong(t.image);
    } catch(java.lang.NumberFormatException e) {
      // Ok try to see if we can parse a Big int 
      //
      try {
         BigInteger v= new BigInteger(t.image);
         if ( max64.compareTo(v) < 0) {
            throw new NumberFormatException();
         }
         // So far so good. Say the value is max a long can be ...
         //
         jjtn000.val=  (long) Long.MAX_VALUE;
      } catch (java.lang.NumberFormatException ee) {
        int lineNb= t.beginLine;
        Integer val= new Integer(lineNb);
        Trace.warning(MessageHandler.getMessage("compile.w.value",t.image, val));
        jjtn000.val=0;
      }
    }
    return jjtn000.val;
    }
| t=<NEGATIVE_INTEGER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
     try {
      jjtn000.val= (long) Long.parseLong(t.image);
    } catch(java.lang.NumberFormatException e) {
      int lineNb= t.beginLine;
      Integer val= new Integer(lineNb);
      Trace.warning(MessageHandler.getMessage("compile.w.value",t.image, val));
      jjtn000.val=0;
    }
    return jjtn000.val;
    }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}



void Enum(ASTIntSubType sup): 
{/*@bgen(jjtree) Enum */
ASTEnum jjtn000 = new ASTEnum(JJTENUM);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);
/*@egen*/
long val;
Token t;
}
{/*@bgen(jjtree) Enum */
try {
/*@egen*/
jjtn000.identifier= Identifier() t="(" jjtn000.val= IntegerValue() 
  {  
    // Add the enum into the hashtable ...
    //
    sup.addEnumDef(jjtn000.identifier, String.valueOf(jjtn000.val));
    if (jjtn000.val == 0) {
     // Get the line number ...
      //
      int lineNb= t.beginLine;
      Trace.warning(MessageHandler.getMessage("compile.w.enum",new Integer(lineNb)));
    }
  }  ")"/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void DefinedType(): {/*@bgen(jjtree) DefinedType */
  ASTDefinedType jjtn000 = new ASTDefinedType(JJTDEFINEDTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) DefinedType */
try {
/*@egen*/
(
   LOOKAHEAD(ExternalTypeReference()) 
   ExternalTypeReference()
| 
  TypeReference()
) 
[
  LOOKAHEAD("(" "SIZE")
  SubType()
| 
  IntSubType()
]/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

String TypeReference(): 
{/*@bgen(jjtree) TypeReference */
  ASTTypeReference jjtn000 = new ASTTypeReference(JJTTYPEREFERENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) TypeReference */
  try {
/*@egen*/
  t=<TYPEREFERENCE>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.symbolName= t.image; 
    return jjtn000.symbolName;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// Similar to ASN.1 X.208
//
void ExternalTypeReference(): 
{/*@bgen(jjtree) ExternalTypeReference */
  ASTExternalTypeReference jjtn000 = new ASTExternalTypeReference(JJTEXTERNALTYPEREFERENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t1;
  Token t2;
}
{/*@bgen(jjtree) ExternalTypeReference */
  try {
/*@egen*/
  t1=<TYPEREFERENCE> "." t2 =<TYPEREFERENCE>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.moduleName = t1.image; 
    jjtn000.symbolName= t2.image;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// Start handling values
//-----------------------

ASTValue Value(): {/*@bgen(jjtree) Value */
  ASTValue jjtn000 = new ASTValue(JJTVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Value */
  try {
/*@egen*/
  DefinedValue()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }
| 
  BooleanValue()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ 
  { return jjtn000; }
| 
  IntegerValue()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ 
  { return jjtn000; }
|
  LOOKAHEAD(3) OidValue()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }
| 
  BitStringValue()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void DefinedValue():
{/*@bgen(jjtree) DefinedValue */
  ASTDefinedValue jjtn000 = new ASTDefinedValue(JJTDEFINEDVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) DefinedValue */
  try {
/*@egen*/
  jjtn000.symbolName=Identifier()
|
  t=<TYPEREFERENCE> "."  jjtn000.symbolName= Identifier()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.moduleName = t.image; 
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// Corresponds to  the ObjectIdentifierValue definition of ASN.1 X.208
//
ASTOidValue OidValue(): {/*@bgen(jjtree) OidValue */
  ASTOidValue jjtn000 = new ASTOidValue(JJTOIDVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OidValue */
try {
/*@egen*/
"{" (ObjectSubID())+ "}"/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{  
  return jjtn000; 
}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

// Corresponds to the ObjIdComponent definition of ASN.1 X.208.
// In addition it contains the notion of DefinedValue which is defined
// as part of the NumberForm in ASN.1
// There are three different forms:
// - NamedForm (identifier)
// - NumberForm (integer)
// - NamedAndNumber form
//
void ObjectSubID(): {/*@bgen(jjtree) ObjectSubID */
  ASTObjectSubID jjtn000 = new ASTObjectSubID(JJTOBJECTSUBID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ObjectSubID */
try {
/*@egen*/
IntegerValue()
|
Identifier() ["(" IntegerValue() ")"]
|
TypeReference() "." Identifier()/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

long IntegerValue() : 
{/*@bgen(jjtree) IntegerValue */
  ASTIntegerValue jjtn000 = new ASTIntegerValue(JJTINTEGERVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) IntegerValue */
  try {
/*@egen*/
  t= <INTEGER_LITERAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
    jjtn000.valStr = t.image;
    try {
      jjtn000.val=  Long.parseLong(t.image);
    } catch(java.lang.NumberFormatException e) {
      jjtn000.val=0;
    }
    return jjtn000.val;
    }
| 
  t=<NEGATIVE_INTEGER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
    jjtn000.valStr = t.image;
    try {
      jjtn000.val= Long.parseLong(t.image);
    } catch(java.lang.NumberFormatException e) {
      jjtn000.val=0;
    }
    return jjtn000.val;
    }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

boolean BooleanValue(): {/*@bgen(jjtree) BooleanValue */
  ASTBooleanValue jjtn000 = new ASTBooleanValue(JJTBOOLEANVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) BooleanValue */
try {
/*@egen*/
"TRUE"/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/ 
    {
    jjtn000.value= true;
    return jjtn000.value;
    }
|
"FALSE"/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/ 
    {
    jjtn000.value= false;
    return jjtn000.value;
    }/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

String BitStringValue(): 
{/*@bgen(jjtree) BitStringValue */
  ASTBitStringValue jjtn000 = new ASTBitStringValue(JJTBITSTRINGVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  ASTNameBitList list;
} 
{/*@bgen(jjtree) BitStringValue */
  try {
/*@egen*/
  t=<BSTRING>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      jjtn000.type= BSTRING;
      jjtn000.value= t.image;
      return jjtn000.value;
    }
| 
  t=<HSTRING>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      jjtn000.type= HSTRING;
      jjtn000.value= t.image;
      return jjtn000.value;
    }
|
 t=<CSTRING>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      jjtn000.type= CSTRING;
      jjtn000.value= t.image;
      return jjtn000.value;
    }
|
  list=NameBitList()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      jjtn000.value = list.getDefValBITS();
      return jjtn000.value;
    }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ASTNameBitList NameBitList(): {/*@bgen(jjtree) NameBitList */
  ASTNameBitList jjtn000 = new ASTNameBitList(JJTNAMEBITLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) NameBitList */
 try {
/*@egen*/
 LOOKAHEAD(2) "{" Identifier() ( "," Identifier())* "}"/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{  
  return jjtn000; 
}
|
 "{" "}"/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{  
  return jjtn000; 
}/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

String Identifier() :
{/*@bgen(jjtree) Identifier */
 ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 Token t;
}
{/*@bgen(jjtree) Identifier */
  try {
/*@egen*/
  t=<IDENTIFIER>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.name = t.image; 
    return jjtn000.name;
  }
|
  t=<NUMBER>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.name = t.image; 
    return jjtn000.name;
  }
|
  t=<STR>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.name = t.image; 
    return jjtn000.name;
  }
|
  t=<DEPRECATED>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.name = t.image; 
    return jjtn000.name;
  }
|
  t=<CURRENT>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.name = t.image; 
    return jjtn000.name;
  }
|
   t=<EMPTY>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.name = t.image; 
    return jjtn000.name;
  }
|
   t=<ID>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.name = t.image; 
    return jjtn000.name;
  }
|
   t=<OPTIONAL>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.name = t.image; 
    return jjtn000.name;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// SNMPv1 or SNMPv2 stuff
//-----------------------

// Index clause
//
ASTIndexTypes IndexTypes(): {/*@bgen(jjtree) IndexTypes */
  ASTIndexTypes jjtn000 = new ASTIndexTypes(JJTINDEXTYPES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IndexTypes */
 try {
/*@egen*/
 "{" Identifier() ("," Identifier())* "}"/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
 { return jjtn000;}/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// SNMPv1 specific macros
//-----------------------
ObjectTypeDefinition ObjectTypeDefinitionV1():
{/*@bgen(jjtree) ObjectTypeDefinitionV1 */
  ASTObjectTypeDefinitionV1 jjtn000 = new ASTObjectTypeDefinitionV1(JJTOBJECTTYPEDEFINITIONV1);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) ObjectTypeDefinitionV1 */
try {
/*@egen*/
"ACCESS"
  (
    "read-only" { jjtn000.access= RO;}
  |
    "read-write" { jjtn000.access= RW;}
  |
    "write-only" { jjtn000.access= WO;}
  |
    "not-accessible" { jjtn000.access= NA;}
  )
"STATUS"
  (
    "mandatory" { jjtn000.status= MANDATORY;}
  |
    "optional" { jjtn000.status= OPTIONAL;}
  |
    "obsolete" { jjtn000.status= OBSOLETE;}
  |
    "deprecated" { jjtn000.status= DEPRECATED;}
  )
// All the other elements are optional !
//
[ "DESCRIPTION" t=<CSTRING> { jjtn000.description= t.image; }]
[ "REFERENCE" t=<CSTRING> { jjtn000.reference= t.image; }]
["INDEX"  jjtn000.indexNode=IndexTypes()]
[ "DEFVAL" "{" jjtn000.defValue=Value() "}"]
"::=" jjtn000.oidNode=OidValue()/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/

{ return (ObjectTypeDefinition) jjtn000; }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

// Trap definition ...
//
void TrapType(): 
{/*@bgen(jjtree) TrapType */
  ASTTrapType jjtn000 = new ASTTrapType(JJTTRAPTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) TrapType */
  try {
/*@egen*/
  "TRAP-TYPE" 
  "ENTERPRISE" (DefinedValue() | OidValue())
[ "VARIABLES" "{" Identifier() ("," Identifier())* "}" ]
[ "DESCRIPTION" t=<CSTRING> { jjtn000.description= t.image; }]
[ "REFERENCE" t=<CSTRING> { jjtn000.reference= t.image; }]
"::="  jjtn000.value= IntegerValue()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/


}

// SNMPv2 specific macros
//------------------------

ObjectTypeDefinition ObjectTypeDefinitionV2():
{/*@bgen(jjtree) ObjectTypeDefinitionV2 */
  ASTObjectTypeDefinitionV2 jjtn000 = new ASTObjectTypeDefinitionV2(JJTOBJECTTYPEDEFINITIONV2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) ObjectTypeDefinitionV2 */
try {
/*@egen*/
[ "UNITS" t=<CSTRING> { jjtn000.description= t.image; }]
"MAX-ACCESS"
  (
    "read-only" { jjtn000.access= RO;}
  |
    "read-write" { jjtn000.access= RW;}
  |
    "read-create" { jjtn000.access= RC;}
  |
    "not-accessible" { jjtn000.access= NA;}
  |
    "accessible-for-notify" {jjtn000.access= AFN;}
  )
"STATUS"
  (
    "current" { jjtn000.status= CURRENT;}
  |
    "obsolete" { jjtn000.status= OBSOLETE;}
  |
    "deprecated" { jjtn000.status= DEPRECATED;}
  )

[ "DESCRIPTION" t=<CSTRING> { jjtn000.description= t.image; }]

// All the other elements are optional !
//
[ "REFERENCE" t=<CSTRING> { jjtn000.reference= t.image; }]

[ jjtn000.indexNode= IndexParts()]
[ "DEFVAL" "{" jjtn000.defValue=Value() "}"]
"::=" jjtn000.oidNode=OidValue()/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/

{ return (ObjectTypeDefinition) jjtn000; }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

// The index clause is a bit more complex in V2 than in V1.
//
ASTIndexParts IndexParts(): {/*@bgen(jjtree) IndexParts */
  ASTIndexParts jjtn000 = new ASTIndexParts(JJTINDEXPARTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) IndexParts */
  try {
/*@egen*/
  "INDEX" {jjtn000.type= INDEX;} IndexTypesV2()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return jjtn000;}
|
  "AUGMENTS" {jjtn000.type= AUGMENTS;} "{" Value() "}"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/

  {return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void IndexTypesV2(): {/*@bgen(jjtree) IndexTypesV2 */
  ASTIndexTypesV2 jjtn000 = new ASTIndexTypesV2(JJTINDEXTYPESV2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) IndexTypesV2 */
try {
/*@egen*/
"{" 
  (
    "IMPLIED" Identifier()
  |
    Identifier()
  )
  ("," 
   (
     "IMPLIED" Identifier()
    |
      Identifier()
    ) 
  )*
"}"/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

// We allow the module identify to be located anywhere in the
// Mib whereas an RFC states that it should be next after the
// import close ...

void ModuleIdentity(ASTMib myMib, String symbolName): 
{/*@bgen(jjtree) ModuleIdentity */
 ASTModuleIdentity jjtn000 = new ASTModuleIdentity(JJTMODULEIDENTITY);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 Token t;
 ASTOidValue oid= null;
}

{/*@bgen(jjtree) ModuleIdentity */
try {
/*@egen*/
"MODULE-IDENTITY"
"LAST-UPDATED"  t=<CSTRING>
  {
     jjtn000.lastUpdate= t.image;
  }

"ORGANIZATION" t=<CSTRING>
  {
     jjtn000.org = t.image;
  }
"CONTACT-INFO" t=<CSTRING>
  {
     jjtn000.contact = t.image;
  }
"DESCRIPTION" t=<CSTRING>
  {
     jjtn000.description= t.image;
  }
(Revision())*
"::=" 
oid= OidValue()/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {  myMib.registerValueDef(symbolName,oid); }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void Revision(): 
{/*@bgen(jjtree) Revision */
 ASTRevision jjtn000 = new ASTRevision(JJTREVISION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/
 Token t;
}
{/*@bgen(jjtree) Revision */
try {
/*@egen*/
"REVISION" t=<CSTRING>
  {
     jjtn000.date= t.image;
  }
"DESCRIPTION" t=<CSTRING>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
     jjtn000.description= t.image;
  }/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

// Textual Convention 
//-------------------

void TextualConvention(ASTMib myMib): 
{/*@bgen(jjtree) TextualConvention */
  ASTTextualConvention jjtn000 = new ASTTextualConvention(JJTTEXTUALCONVENTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) TextualConvention */
 try {
/*@egen*/
 t=<TYPEREFERENCE> {jjtn000.symbolName= t.image;}
 "::=" "TEXTUAL-CONVENTION"
[
  "DISPLAY-HINT" t=<CSTRING>  { jjtn000.hint= t.image; }
]
"STATUS"
(
    "current" { jjtn000.status= CURRENT;}
  |
    "obsolete" { jjtn000.status= OBSOLETE;}
  |
    "deprecated" { jjtn000.status= DEPRECATED;}
)
"DESCRIPTION" t=<CSTRING> { jjtn000.description= t.image; }
[
  "REFERENCE" t=<CSTRING> { jjtn000.reference= t.image; }
]
"SYNTAX" Type()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ 
  { 
    myMib.registerSyntaxDef(jjtn000.symbolName, jjtn000);
  }/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// Module Compliance
//------------------
void ModuleCompliance(): 
{/*@bgen(jjtree) ModuleCompliance */
  ASTModuleCompliance jjtn000 = new ASTModuleCompliance(JJTMODULECOMPLIANCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) ModuleCompliance */
try {
/*@egen*/
"MODULE-COMPLIANCE"
"STATUS"
  (
    "current" { jjtn000.status= CURRENT;}
  |
    "obsolete" { jjtn000.status= OBSOLETE;}
  |
    "deprecated" { jjtn000.status= DEPRECATED;}
  )
"DESCRIPTION" t=<CSTRING>
  {
     jjtn000.description= t.image;
  }
[ "REFERENCE" t=<CSTRING> { jjtn000.reference= t.image; }]
(Module())*
 "::=" jjtn000.oidNode= OidValue()/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void Module():
{/*@bgen(jjtree) Module */
  ASTModule jjtn000 = new ASTModule(JJTMODULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Module */
  try {
/*@egen*/
  "MODULE" [jjtn000.moduleIdentifier= ModuleIdentifier()]
  "MANDATORY-GROUPS" "{" Identifier() ("," Identifier())* "}"
  (Compliance())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
 
}

void Compliance(): {/*@bgen(jjtree) Compliance */
  ASTCompliance jjtn000 = new ASTCompliance(JJTCOMPLIANCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Compliance */
  try {
/*@egen*/
  ComplianceGroup()
|
  Object()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ComplianceGroup(): 
{/*@bgen(jjtree) ComplianceGroup */
  ASTComplianceGroup jjtn000 = new ASTComplianceGroup(JJTCOMPLIANCEGROUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) ComplianceGroup */
  try {
/*@egen*/
  "GROUP" jjtn000.identifier=Identifier()
  // do not store this description ! Who cares ?
  //
  "DESCRIPTION" <CSTRING>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Object(): {/*@bgen(jjtree) Object */
  ASTObject jjtn000 = new ASTObject(JJTOBJECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Object */
  try {
/*@egen*/
  "OBJECT" jjtn000.identifier= Identifier()
  ["SYNTAX" Type()]
  ["WRITE-SYNTAX" Type()]
  [ "MIN-ACCESS"
    (
      "read-only" { jjtn000.access= RO;}
    |
      "read-write" { jjtn000.access= RW;}
    |
      "read-create" { jjtn000.access= RC;}
    |
      "not-accessible" { jjtn000.access= NA;}
    |
      "accessible-for-notify" {jjtn000.access= AFN;}
    )
  ]

  // do not store this description ! Who cares ?
  //
  "DESCRIPTION" <CSTRING>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ObjectIdentity(ASTMib myMib, String symbolName): 
{/*@bgen(jjtree) ObjectIdentity */
  ASTObjectIdentity jjtn000 = new ASTObjectIdentity(JJTOBJECTIDENTITY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) ObjectIdentity */
try {
/*@egen*/
"OBJECT-IDENTITY"

"STATUS"
  (
    "current" { jjtn000.status= CURRENT;}
  |
    "obsolete" { jjtn000.status= OBSOLETE;}
  |
    "deprecated" { jjtn000.status= DEPRECATED;}
  )
"DESCRIPTION" t=<CSTRING> { jjtn000.description= t.image; }
[ "REFERENCE" t=<CSTRING> { jjtn000.reference= t.image; }]
"::=" jjtn000.oid= OidValue()/*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                              }
/*@egen*/ { 
    myMib.registerObjectIdentity(symbolName, jjtn000);
  }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void NotificationType(ASTMib myMib, String symbolName): 
{/*@bgen(jjtree) NotificationType */
  ASTNotificationType jjtn000 = new ASTNotificationType(JJTNOTIFICATIONTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) NotificationType */
try {
/*@egen*/
"NOTIFICATION-TYPE" 
[
  "OBJECTS" jjtn000.objectParts=ObjectsPart()
]
"STATUS"
  (
    "current" { jjtn000.status= CURRENT;}
  |
    "obsolete" { jjtn000.status= OBSOLETE;}
  |
    "deprecated" { jjtn000.status= DEPRECATED;}
  )
"DESCRIPTION" t=<CSTRING> { jjtn000.description= t.image; }
[ "REFERENCE" t=<CSTRING> { jjtn000.reference= t.image; }]
"::=" jjtn000.oid= OidValue()/*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                              }
/*@egen*/ {
	myMib.registerNotificationType(symbolName,jjtn000);
    }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

Node ObjectsPart(): {/*@bgen(jjtree) ObjectsPart */
  ASTObjectsPart jjtn000 = new ASTObjectsPart(JJTOBJECTSPART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) ObjectsPart */
try {
/*@egen*/
"{" Identifier()  ("," Identifier())* "}"/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   { return jjtn000; }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}


// Handle the OBJECT-GROUP macro...
//---------------------------------
void ObjectGroup(ASTMib myMib, String symbolName):
{/*@bgen(jjtree) ObjectGroup */
  ASTObjectGroup jjtn000 = new ASTObjectGroup(JJTOBJECTGROUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) ObjectGroup */
try {
/*@egen*/
"OBJECT-GROUP"
[
  "OBJECTS" ObjectsPart()
]
"STATUS"
  (
    "current" { jjtn000.status= CURRENT;}
  |
    "obsolete" { jjtn000.status= OBSOLETE;}
  |
    "deprecated" { jjtn000.status= DEPRECATED;}
  )
"DESCRIPTION" t=<CSTRING> { jjtn000.description= t.image; }
[ 
  "REFERENCE" t=<CSTRING> { jjtn000.reference= t.image; }
]
"::=" jjtn000.oid= OidValue()/*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                              }
/*@egen*/ {
    myMib.registerObjectGroup(symbolName, jjtn000);
 }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

// Handle the Notification Group macro
//------------------------------------
void NotificationGroup(ASTMib myMib, String symbolName):
{/*@bgen(jjtree) NotificationGroup */
  ASTNotificationGroup jjtn000 = new ASTNotificationGroup(JJTNOTIFICATIONGROUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) NotificationGroup */
try {
/*@egen*/

"NOTIFICATION-GROUP"

"NOTIFICATIONS" ObjectsPart()

"STATUS"
  (
    "current" { jjtn000.status= CURRENT;}
  |
    "obsolete" { jjtn000.status= OBSOLETE;}
  |
    "deprecated" { jjtn000.status= DEPRECATED;}
  )
"DESCRIPTION" t=<CSTRING> { jjtn000.description= t.image; }
[ 
  "REFERENCE" t=<CSTRING> { jjtn000.reference= t.image; }
]
"::=" jjtn000.oid= OidValue()/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                               }
/*@egen*/  {
    myMib.registerNotifGroup(symbolName, jjtn000);
 }/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}


// Hack to simplify parsing ...
//-----------------------------
String Reserved(): 
{/*@bgen(jjtree) Reserved */
  ASTReserved jjtn000 = new ASTReserved(JJTRESERVED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Reserved */
 try {
/*@egen*/
 t=<TEXTUAL_CONVENTION>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ {jjtn000.type= TEXTUAL_CONVENTION; return t.image;}
|
 t=<OBJECT_TYPE>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.type= OBJECT_TYPE; return t.image;}
|
t=<OBJECT_IDENTITY>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ {jjtn000.type= OBJECT_IDENTITY;return t.image;}
|
t=<MODULE_IDENTITY>/*@bgen(jjtree)*/
                    {
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                    }
/*@egen*/ {jjtn000.type= MODULE_IDENTITY;return t.image;}
|
t=<MODULE_COMPLIANCE>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/ {jjtn000.type= MODULE_COMPLIANCE;return t.image;}
|
t=<AGENT>/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ {jjtn000.type= AGENT;return t.image;}
|
t=<TRAP_TYPE>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ {jjtn000.type= TRAP_TYPE;return t.image;}
|
t=<NOTIFICATION_TYPE>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/{jjtn000.type= NOTIFICATION_TYPE;return t.image;}
|
t=<OBJECT_GROUP>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/{jjtn000.type= OBJECT_GROUP;return t.image;}
|
t=<NOTIFICATION_GROUP>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/{jjtn000.type= NOTIFICATION_GROUP;return t.image;}
|
t=<TYPE>/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/ {jjtn000.type= TYPE;return t.image;}
|
t=<SYNTAX>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ {jjtn000.type= SYNTAX;return t.image;}/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}


// Simple handling of macro. Just parse the XXX stuff !
//-------------------------
void MacroDefinition(): {/*@bgen(jjtree) MacroDefinition */
  ASTMacroDefinition jjtn000 = new ASTMacroDefinition(JJTMACRODEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) MacroDefinition */
try {
/*@egen*/
(jjtn000.symbolName= TypeReference()| jjtn000.symbolName=Reserved())
"MACRO" "::=" "BEGIN" MacroBody() "END"/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void MacroBody(): {/*@bgen(jjtree) MacroBody */
  ASTMacroBody jjtn000 = new ASTMacroBody(JJTMACROBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) MacroBody */
try {
/*@egen*/
// Type Production ...
"TYPE" "NOTATION" "::=" MacroAlternativeList()

// Value Production ...
//
"VALUE" "NOTATION" "::=" MacroAlternativeList()

// Supporting Production (optional)
//
(TypeReference() "::=" MacroAlternativeList())*/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void MacroAlternativeList(): {/*@bgen(jjtree) MacroAlternativeList */
  ASTMacroAlternativeList jjtn000 = new ASTMacroAlternativeList(JJTMACROALTERNATIVELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) MacroAlternativeList */
try {
/*@egen*/
MacroAlternative() ("|" MacroAlternative())*/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void MacroAlternative(): {/*@bgen(jjtree) MacroAlternative */
  ASTMacroAlternative jjtn000 = new ASTMacroAlternative(JJTMACROALTERNATIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) MacroAlternative */
try {
/*@egen*/
(SymbolElement())+/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void SymbolElement(): {/*@bgen(jjtree) SymbolElement */
  ASTSymbolElement jjtn000 = new ASTSymbolElement(JJTSYMBOLELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) SymbolElement */
  try {
/*@egen*/
  SymbolDefn() 
|
  "<" EmbeddedDefinitions() ">"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SymbolDefn(): 
{/*@bgen(jjtree) SymbolDefn */
  ASTSymbolDefn jjtn000 = new ASTSymbolDefn(JJTSYMBOLDEFN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ 
  Token t;
}
{/*@bgen(jjtree) SymbolDefn */
try {
/*@egen*/
"string"
|
"identifier"
|
"number"
|
"empty"
|
<CSTRING>
|
"value" "("  ("VALUE" MacroType() | TypeReference() [Type()]) ")"
|
"type" [ "(" MacroType() ")"]
|
LOOKAHEAD(TypeReference(), {getToken(2).kind != ASSIGN})
TypeReference()
|
t=<IDENTIFIER>/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void EmbeddedDefinitions(): {/*@bgen(jjtree) EmbeddedDefinitions */
  ASTEmbeddedDefinitions jjtn000 = new ASTEmbeddedDefinitions(JJTEMBEDDEDDEFINITIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) EmbeddedDefinitions */
try {
/*@egen*/
LocalTypeAssignment()
|
LocalValueAssignment()/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void LocalTypeAssignment(): {/*@bgen(jjtree) LocalTypeAssignment */
  ASTLocalTypeAssignment jjtn000 = new ASTLocalTypeAssignment(JJTLOCALTYPEASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) LocalTypeAssignment */
try {
/*@egen*/
TypeReference() "::=" MacroType()/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void LocalValueAssignment(): {/*@bgen(jjtree) LocalValueAssignment */
  ASTLocalValueAssignment jjtn000 = new ASTLocalValueAssignment(JJTLOCALVALUEASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) LocalValueAssignment */
try {
/*@egen*/
Identifier() MacroType() "::=" Value()/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void MacroType(): {/*@bgen(jjtree) MacroType */
  ASTMacroType jjtn000 = new ASTMacroType(JJTMACROTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) MacroType */
try {
/*@egen*/
(
Reserved()
|
Type()
)+/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

// Finally handle the AGENT-CAPABILITIES
//--------------------------------------
void AgentCapabilities()      : { }
{
"AGENT-CAPABILITIES" skip_agentCapabilitiesDef() OidValue()
}

void skip_agentCapabilitiesDef()      : {
  Token tok;
}
{
{
  tok= getNextToken();
  while (tok.kind != EOF) {
    if (tok.kind == ASSIGN) {
       break;
    }
    tok= getNextToken();
  }
  if (tok.kind == EOF) {
    String eol = System.getProperty("line.separator", "\n");
    throw new ParseException(MessageHandler.getMessage("parse.exception.msg.pos",
      "<EOF>",
      new Integer(tok.beginLine),
      new Integer(tok.beginColumn)) +
      eol + "    " + 
      MessageHandler.getMessage("parse.exception.msg.exp", "::="));
  }
}
}
    



