/*
 * @(#)Parser.java	4.12
 *
 * 
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 * 
 * Copyright (c) 2007 Sun Microsystems, Inc. All Rights Reserved.
 * 
 * The contents of this file are subject to the terms of either the GNU General
 * Public License Version 2 only ("GPL") or the Common Development and
 * Distribution License("CDDL")(collectively, the "License"). You may not use
 * this file except in compliance with the License. You can obtain a copy of the
 * License at http://opendmk.dev.java.net/legal_notices/licenses.txt or in the 
 * LEGAL_NOTICES folder that accompanied this code. See the License for the 
 * specific language governing permissions and limitations under the License.
 * 
 * When distributing the software, include this License Header Notice in each
 * file and include the License file found at
 *     http://opendmk.dev.java.net/legal_notices/licenses.txt
 * or in the LEGAL_NOTICES folder that accompanied this code.
 * Sun designates this particular file as subject to the "Classpath" exception
 * as provided by Sun in the GPL Version 2 section of the License file that
 * accompanied this code.
 * 
 * If applicable, add the following below the License Header, with the fields
 * enclosed by brackets [] replaced by your own identifying information:
 * 
 *       "Portions Copyrighted [year] [name of copyright owner]"
 * 
 * Contributor(s):
 * 
 * If you wish your version of this file to be governed by only the CDDL or
 * only the GPL Version 2, indicate your decision by adding
 * 
 *       "[Contributor] elects to include this software in this distribution
 *        under the [CDDL or GPL Version 2] license."
 * 
 * If you don't indicate a single choice of license, a recipient has the option
 * to distribute your version of this file under either the CDDL or the GPL
 * Version 2, or to extend the choice of license to its licensees as provided
 * above. However, if you add GPL Version 2 code and therefore, elected the
 * GPL Version 2 license, then the option applies only if the new code is made
 * subject to such option by the copyright holder.
 * 
 *
 */
/* Generated By:JJTree&JavaCC: Do not edit this line. Parser.java */
package com.sun.jdmk.tools.mibgen;


import java.io.*;
import java.math.*;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants, ParserConstants {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();protected boolean snmpV2= false;
static BigInteger max64= new BigInteger("18446744073709551615");

// A file can contain several different modules
//
  final public ASTMibs Mibs(ModulesHandler handler) throws ParseException, SemanticException {
                                                                 /*@bgen(jjtree) Mibs */
  ASTMibs jjtn000 = new ASTMibs(JJTMIBS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        Mib(handler);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TYPEREFERENCE:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    if (jjte000 instanceof SemanticException) {
      {if (true) throw (SemanticException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

// Definition of a MIB. Identical to an ASN.1 module
//
  final public void Mib(ModulesHandler handler) throws ParseException, SemanticException {
                                                            /*@bgen(jjtree) Mib */
  ASTMib jjtn000 = new ASTMib(JJTMIB);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jjtn000.moduleIdentifier = ModuleIdentifier();
      jj_consume_token(DEFINITIONS);
      jj_consume_token(ASSIGN);
      jj_consume_token(BEGIN);
      ModuleBody(jjtn000);
      jj_consume_token(END);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
     // Register the mib !
     //
     handler.addMibModule(jjtn000.moduleIdentifier.getModuleName(), jjtn000);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    if (jjte000 instanceof SemanticException) {
      {if (true) throw (SemanticException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

// Definition of a module identifier. Can contain an oid ...
//
  final public ASTModuleIdentifier ModuleIdentifier() throws ParseException {
 /*@bgen(jjtree) ModuleIdentifier */
  ASTModuleIdentifier jjtn000 = new ASTModuleIdentifier(JJTMODULEIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(TYPEREFERENCE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 104:
        OidValue();
        break;
      default:
        jj_la1[1] = jj_gen;
        ;
      }
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
     jjtn000.moduleName= t.image;
     if (jjtn000.moduleName.equals("SNMPv2-SMI")) {
        snmpV2= true;
     }
     {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
    throw new Error("Missing return statement in function");
  }

// Definition of a ModuleBody. 
//
  final public void ModuleBody(ASTMib myMib) throws ParseException, SemanticException {
                                                          /*@bgen(jjtree) ModuleBody */
  ASTModuleBody jjtn000 = new ASTModuleBody(JJTMODULEBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPORTS:
        Exports();
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORTS:
        Imports();
        break;
      default:
        jj_la1[3] = jj_gen;
        ;
      }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AGENT:
        case CURRENT:
        case DEPRECATED:
        case EMPTY:
        case ID:
        case MODULE_COMPLIANCE:
        case MODULE_IDENTITY:
        case NOTIFICATION_GROUP:
        case NOTIFICATION_TYPE:
        case NUMBER:
        case OBJECT_IDENTITY:
        case OBJECT_GROUP:
        case OBJECT_TYPE:
        case OPTIONAL:
        case STR:
        case SYNTAX:
        case TEXTUAL_CONVENTION:
        case TRAP_TYPE:
        case TYPE:
        case IDENTIFIER:
        case TYPEREFERENCE:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_2;
        }
        Assignment(myMib);
      }
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  if (jjte000 instanceof SemanticException) {
    {if (true) throw (SemanticException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void Assignment(ASTMib myMib) throws ParseException, SemanticException {
                                                          /*@bgen(jjtree) Assignment */
  ASTAssignment jjtn000 = new ASTAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT:
      case DEPRECATED:
      case EMPTY:
      case ID:
      case NUMBER:
      case OPTIONAL:
      case STR:
      case IDENTIFIER:
        jjtn000.symbolName = Identifier();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BIT:
        case BITS:
        case CHOICE:
        case INTEGER:
        case NULL:
        case OBJECT:
        case OCTET:
        case SEQUENCE:
        case TYPEREFERENCE:
        case 99:
          ValueDefinition(myMib, jjtn000.symbolName);
          break;
        case OBJECT_TYPE:
          ObjectTypeDefinition(myMib, jjtn000.symbolName);
          break;
        case MODULE_IDENTITY:
          ModuleIdentity(myMib, jjtn000.symbolName);
          break;
        case MODULE_COMPLIANCE:
          ModuleCompliance();
          break;
        case AGENT:
          AgentCapabilities();
          break;
        case OBJECT_IDENTITY:
          ObjectIdentity(myMib, jjtn000.symbolName);
          break;
        case TRAP_TYPE:
          TrapType();
          break;
        case NOTIFICATION_TYPE:
          NotificationType(myMib, jjtn000.symbolName);
          break;
        case OBJECT_GROUP:
          ObjectGroup(myMib, jjtn000.symbolName);
          break;
        case NOTIFICATION_GROUP:
          NotificationGroup(myMib, jjtn000.symbolName);
          break;
        default:
          jj_la1[5] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[6] = jj_gen;
        if (jj_2_1(2147483647)) {
          TextualConvention(myMib);
        } else if (jj_2_2(2147483647)) {
          SyntaxDefinition(myMib);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case AGENT:
          case MODULE_COMPLIANCE:
          case MODULE_IDENTITY:
          case NOTIFICATION_GROUP:
          case NOTIFICATION_TYPE:
          case OBJECT_IDENTITY:
          case OBJECT_GROUP:
          case OBJECT_TYPE:
          case SYNTAX:
          case TEXTUAL_CONVENTION:
          case TRAP_TYPE:
          case TYPE:
          case TYPEREFERENCE:
            MacroDefinition();
            break;
          default:
            jj_la1[7] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void SyntaxDefinition(ASTMib myMib) throws ParseException {
                                      /*@bgen(jjtree) SyntaxDefinition */
  ASTSyntaxDefinition jjtn000 = new ASTSyntaxDefinition(JJTSYNTAXDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jjtn000.symbolName = TypeReference();
      jj_consume_token(ASSIGN);
      jjtn000.type = NamedType();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    myMib.registerSyntaxDef(jjtn000.symbolName, jjtn000);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

// At the moment only accept types supported by the different SNMP SMI.
// 
  final public ASTNamedType NamedType() throws ParseException {
                           /*@bgen(jjtree) NamedType */
  ASTNamedType jjtn000 = new ASTNamedType(JJTNAMEDTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Type();
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
  {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
    throw new Error("Missing return statement in function");
  }

  final public void ObjectTypeDefinition(ASTMib myMib, String symbolName) throws ParseException {
                                                             /*@bgen(jjtree) ObjectTypeDefinition */
  ASTObjectTypeDefinition jjtn000 = new ASTObjectTypeDefinition(JJTOBJECTTYPEDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(OBJECT_TYPE);
      jj_consume_token(SYNTAX);
      jjtn000.syntax = NamedType();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MAXACCESS:
      case UNITS:
        jjtn000.def = ObjectTypeDefinitionV2();
                                           jjtree.closeNodeScope(jjtn000, true);
                                           jjtc000 = false;
                                           myMib.registerV2ObjectType(symbolName,jjtn000);
        break;
      case ACCESS:
        jjtn000.def = ObjectTypeDefinitionV1();
                                          jjtree.closeNodeScope(jjtn000, true);
                                          jjtc000 = false;
                                          myMib.registerV1ObjectType(symbolName,jjtn000);
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

// Start Handling of values.
//

// The identifier is read in the previous rule (Assignment)
//
  final public void ValueDefinition(ASTMib myMib, String symbolName) throws ParseException {
                                                        /*@bgen(jjtree) ValueDefinition */
  ASTValueDefinition jjtn000 = new ASTValueDefinition(JJTVALUEDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Type();
      jj_consume_token(ASSIGN);
      Value();
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                       myMib.registerValueDef(symbolName,jjtn000);
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

// Handle list of exports. Somewhere in one of the RFC it says that
// export should not be used. We never know ...
//
  final public void Exports() throws ParseException {
 /*@bgen(jjtree) Exports */
  ASTExports jjtn000 = new ASTExports(JJTEXPORTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(EXPORTS);
    // Get the line number ...
    //
    int lineNb= t.beginLine;
    Integer val= new Integer(lineNb);
    Trace.warning(MessageHandler.getMessage("compile.w.export",val));
      SymbolsList();
      jj_consume_token(SEMICOLON);
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void Imports() throws ParseException {
                  /*@bgen(jjtree) Imports */
  ASTImports jjtn000 = new ASTImports(JJTIMPORTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(IMPORTS);
      SymbolsImported();
      jj_consume_token(SEMICOLON);
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void SymbolsImported() throws ParseException {
                         /*@bgen(jjtree) SymbolsImported */
  ASTSymbolsImported jjtn000 = new ASTSymbolsImported(JJTSYMBOLSIMPORTED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AGENT:
        case CURRENT:
        case DEPRECATED:
        case EMPTY:
        case ID:
        case MODULE_COMPLIANCE:
        case MODULE_IDENTITY:
        case NOTIFICATION_GROUP:
        case NOTIFICATION_TYPE:
        case NUMBER:
        case OBJECT_IDENTITY:
        case OBJECT_GROUP:
        case OBJECT_TYPE:
        case OPTIONAL:
        case STR:
        case SYNTAX:
        case TEXTUAL_CONVENTION:
        case TRAP_TYPE:
        case TYPE:
        case IDENTIFIER:
        case TYPEREFERENCE:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_3;
        }
        SymbolsList();
        jj_consume_token(FROM);
        ModuleIdentifier();
      }
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void SymbolsList() throws ParseException {
                     /*@bgen(jjtree) SymbolsList */
  ASTSymbolsList jjtn000 = new ASTSymbolsList(JJTSYMBOLSLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT:
      case DEPRECATED:
      case EMPTY:
      case ID:
      case NUMBER:
      case OPTIONAL:
      case STR:
      case IDENTIFIER:
        Identifier();
        break;
      case TYPEREFERENCE:
        TypeReference();
        break;
      case AGENT:
      case MODULE_COMPLIANCE:
      case MODULE_IDENTITY:
      case NOTIFICATION_GROUP:
      case NOTIFICATION_TYPE:
      case OBJECT_IDENTITY:
      case OBJECT_GROUP:
      case OBJECT_TYPE:
      case SYNTAX:
      case TEXTUAL_CONVENTION:
      case TRAP_TYPE:
      case TYPE:
        Reserved();
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CURRENT:
        case DEPRECATED:
        case EMPTY:
        case ID:
        case NUMBER:
        case OPTIONAL:
        case STR:
        case IDENTIFIER:
          Identifier();
          break;
        case TYPEREFERENCE:
          TypeReference();
          break;
        case AGENT:
        case MODULE_COMPLIANCE:
        case MODULE_IDENTITY:
        case NOTIFICATION_GROUP:
        case NOTIFICATION_TYPE:
        case OBJECT_IDENTITY:
        case OBJECT_GROUP:
        case OBJECT_TYPE:
        case SYNTAX:
        case TEXTUAL_CONVENTION:
        case TRAP_TYPE:
        case TYPE:
          Reserved();
          break;
        default:
          jj_la1[12] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Type() throws ParseException {
              /*@bgen(jjtree) Type */
  ASTType jjtn000 = new ASTType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT:
      case BITS:
      case CHOICE:
      case INTEGER:
      case NULL:
      case OBJECT:
      case OCTET:
      case SEQUENCE:
      case 99:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 99:
          jjtn000.tag = Tag();
          break;
        default:
          jj_la1[13] = jj_gen;
          ;
        }
        BuiltinType();
        break;
      case TYPEREFERENCE:
        DefinedType();
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void BuiltinType() throws ParseException {
                     /*@bgen(jjtree) BuiltinType */
  ASTBuiltinType jjtn000 = new ASTBuiltinType(JJTBUILTINTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
        jj_consume_token(INTEGER);
             jjtn000.type= INTEGER;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 101:
        case 104:
          IntSubType();
          break;
        default:
          jj_la1[15] = jj_gen;
          ;
        }
        break;
      case OCTET:
        jj_consume_token(OCTET);
        jj_consume_token(STRING);
                    jjtn000.type= OCTET;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 101:
          SubType();
          break;
        default:
          jj_la1[16] = jj_gen;
          ;
        }
        break;
      case OBJECT:
        jj_consume_token(OBJECT);
        jj_consume_token(IDENT);
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                         jjtn000.type= OBJECT;
        break;
      case BIT:
        jj_consume_token(BIT);
        jj_consume_token(STRING);
                  jjtn000.type=BIT;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 104:
          NamedBitList();
          break;
        default:
          jj_la1[17] = jj_gen;
          ;
        }
        break;
      case BITS:
        jj_consume_token(BITS);
          jjtn000.type=BIT;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 104:
          NamedBitList();
          break;
        default:
          jj_la1[18] = jj_gen;
          ;
        }
        break;
      case NULL:
        jj_consume_token(NULL);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
          jjtn000.type= NULL;
        break;
      case SEQUENCE:
        jj_consume_token(SEQUENCE);
             jjtn000.type= SEQUENCE;
        SequenceType();
        break;
      case CHOICE:
        jj_consume_token(CHOICE);
           jjtn000.type= CHOICE;
        ChoiceType();
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public ASTTag Tag() throws ParseException {
 /*@bgen(jjtree) Tag */
  ASTTag jjtn000 = new ASTTag(JJTTAG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(99);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case APPLICATION:
      case UNIVERSAL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case UNIVERSAL:
          jj_consume_token(UNIVERSAL);
                    jjtn000.classType= UNIVERSAL;
          break;
        case APPLICATION:
          jj_consume_token(APPLICATION);
                      jjtn000.classType= APPLICATION;
          break;
        default:
          jj_la1[20] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[21] = jj_gen;
        ;
      }
      jjtn000.classNumber = IntegerValue();
      jj_consume_token(100);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPLICIT:
      case IMPLICIT:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IMPLICIT:
          jj_consume_token(IMPLICIT);
               jjtn000.implicit= true;
          break;
        case EXPLICIT:
          jj_consume_token(EXPLICIT);
              jjtn000.implicit= false;
          break;
        default:
          jj_la1[22] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
 {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
    throw new Error("Missing return statement in function");
  }

  final public void SubType() throws ParseException {
                 /*@bgen(jjtree) SubType */
  ASTSubType jjtn000 = new ASTSubType(JJTSUBTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(101);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SIZE:
        jj_consume_token(SIZE);
        jj_consume_token(101);
        Range();
        label_5:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 102:
            ;
            break;
          default:
            jj_la1[24] = jj_gen;
            break label_5;
          }
          jj_consume_token(102);
          Range();
        }
        jj_consume_token(103);
        break;
      case INTEGER_LITERAL:
      case NEGATIVE_INTEGER:
      case BSTRING:
      case HSTRING:
        Range();
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(103);
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void SequenceType() throws ParseException {
                      /*@bgen(jjtree) SequenceType */
  ASTSequenceType jjtn000 = new ASTSequenceType(JJTSEQUENCETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 104:
        jj_consume_token(104);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CURRENT:
        case DEPRECATED:
        case EMPTY:
        case ID:
        case NUMBER:
        case OPTIONAL:
        case STR:
        case IDENTIFIER:
          Identifier();
          break;
        default:
          jj_la1[26] = jj_gen;
          ;
        }
        Type();
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[27] = jj_gen;
            break label_6;
          }
          jj_consume_token(COMMA);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CURRENT:
          case DEPRECATED:
          case EMPTY:
          case ID:
          case NUMBER:
          case OPTIONAL:
          case STR:
          case IDENTIFIER:
            Identifier();
            break;
          default:
            jj_la1[28] = jj_gen;
            ;
          }
          Type();
        }
        jj_consume_token(105);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   jjtn000.type= SEQUENCE;
        break;
      case OF:
        jj_consume_token(OF);
       jjtn000.type= OF;
        Type();
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void ChoiceType() throws ParseException {
                    /*@bgen(jjtree) ChoiceType */
  ASTChoiceType jjtn000 = new ASTChoiceType(JJTCHOICETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(104);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT:
      case DEPRECATED:
      case EMPTY:
      case ID:
      case NUMBER:
      case OPTIONAL:
      case STR:
      case IDENTIFIER:
        Identifier();
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      Type();
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[31] = jj_gen;
          break label_7;
        }
        jj_consume_token(COMMA);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CURRENT:
        case DEPRECATED:
        case EMPTY:
        case ID:
        case NUMBER:
        case OPTIONAL:
        case STR:
        case IDENTIFIER:
          Identifier();
          break;
        default:
          jj_la1[32] = jj_gen;
          ;
        }
        Type();
      }
      jj_consume_token(105);
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

// Support only the kibble form i.e identifier(nonNegativeNumber) !
//
  final public void NamedBitList() throws ParseException {
                      /*@bgen(jjtree) NamedBitList */
  ASTNamedBitList jjtn000 = new ASTNamedBitList(JJTNAMEDBITLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(104);
      Kibble(jjtn000);
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[33] = jj_gen;
          break label_8;
        }
        jj_consume_token(COMMA);
        Kibble(jjtn000);
      }
      jj_consume_token(105);
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  final public void Kibble(ASTNamedBitList sup) throws ParseException {
 /*@bgen(jjtree) Kibble */
ASTKibble jjtn000 = new ASTKibble(JJTKIBBLE);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token t;
    try {
      jjtn000.name = Identifier();
      jj_consume_token(101);
      t = jj_consume_token(INTEGER_LITERAL);
    jjtn000.value= Integer.parseInt(t.image);
    // Add the enum into the hashtable ...
    //
    sup.addEnumDef(jjtn000.name, new String(t.image.trim()));
      jj_consume_token(103);
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

// When dealing with an INTEGER, we can have a enum
// or a size restriction.
  final public void IntSubType() throws ParseException {
                    /*@bgen(jjtree) IntSubType */
  ASTIntSubType jjtn000 = new ASTIntSubType(JJTINTSUBTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 104:
        jj_consume_token(104);
        Enum(jjtn000);
        label_9:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[34] = jj_gen;
            break label_9;
          }
          jj_consume_token(COMMA);
          Enum(jjtn000);
        }
        jj_consume_token(105);
        break;
      case 101:
        jj_consume_token(101);
        Range();
        label_10:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 102:
            ;
            break;
          default:
            jj_la1[35] = jj_gen;
            break label_10;
          }
          jj_consume_token(102);
          Range();
        }
        jj_consume_token(103);
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void Range() throws ParseException {
 /*@bgen(jjtree) Range */
  ASTRange jjtn000 = new ASTRange(JJTRANGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      jjtn000.low = RangeValue();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RANGE:
        t = jj_consume_token(RANGE);
        jjtn000.high = RangeValue();
    if (jjtn000.low > jjtn000.high) {
      // Get the line number ...
      //
      int lineNb= t.beginLine;
      Integer val= new Integer(lineNb);
      Trace.warning(MessageHandler.getMessage("compile.w.range",val));
    }
        break;
      default:
        jj_la1[37] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public long RangeValue() throws ParseException {
 /*@bgen(jjtree) RangeValue */
  ASTRangeValue jjtn000 = new ASTRangeValue(JJTRANGEVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BSTRING:
        t = jj_consume_token(BSTRING);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    try {
      int length= t.image.length();
      if (length >=3) {
         String val= t.image.toLowerCase();
         val= val.substring(0, val.lastIndexOf("b"));
         val= val.replace('\'', ' ').trim();
         jjtn000.val=  (long) Integer.parseInt(val, 2);
      } else {
        jjtn000.val=0;
      }
    } catch(java.lang.NumberFormatException e) {
      int lineNb= t.beginLine;
      Integer val= new Integer(lineNb);
      Trace.warning(MessageHandler.getMessage("compile.w.value",t.image, val));
      jjtn000.val=0;
    }
    {if (true) return jjtn000.val;}
        break;
      case HSTRING:
        t = jj_consume_token(HSTRING);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    try {
      int length= t.image.length();
      if (length >=3) {
         String val= t.image.toLowerCase();
         val= val.substring(0, val.lastIndexOf("h"));
         val= val.replace('\'', ' ').trim();
         if (val.length() > 8)
            {if (true) throw new NumberFormatException();}
         jjtn000.val=  (long) Long.parseLong(val, 16);
      } else {
        jjtn000.val=0;
      }
    } catch(java.lang.NumberFormatException e) {
      int lineNb= t.beginLine;
      Integer val= new Integer(lineNb);
      Trace.warning(MessageHandler.getMessage("compile.w.value",t.image, val));
      jjtn000.val=0;
    }
    {if (true) return jjtn000.val;}
        break;
      case INTEGER_LITERAL:
        t = jj_consume_token(INTEGER_LITERAL);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    try {
      jjtn000.val=  (long) Long.parseLong(t.image);
    } catch(java.lang.NumberFormatException e) {
      // Ok try to see if we can parse a Big int 
      //
      try {
         BigInteger v= new BigInteger(t.image);
         if ( max64.compareTo(v) < 0) {
            {if (true) throw new NumberFormatException();}
         }
         // So far so good. Say the value is max a long can be ...
         //
         jjtn000.val=  (long) Long.MAX_VALUE;
      } catch (java.lang.NumberFormatException ee) {
        int lineNb= t.beginLine;
        Integer val= new Integer(lineNb);
        Trace.warning(MessageHandler.getMessage("compile.w.value",t.image, val));
        jjtn000.val=0;
      }
    }
    {if (true) return jjtn000.val;}
        break;
      case NEGATIVE_INTEGER:
        t = jj_consume_token(NEGATIVE_INTEGER);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
     try {
      jjtn000.val= (long) Long.parseLong(t.image);
    } catch(java.lang.NumberFormatException e) {
      int lineNb= t.beginLine;
      Integer val= new Integer(lineNb);
      Trace.warning(MessageHandler.getMessage("compile.w.value",t.image, val));
      jjtn000.val=0;
    }
    {if (true) return jjtn000.val;}
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void Enum(ASTIntSubType sup) throws ParseException {
 /*@bgen(jjtree) Enum */
ASTEnum jjtn000 = new ASTEnum(JJTENUM);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);long val;
Token t;
    try {
      jjtn000.identifier = Identifier();
      t = jj_consume_token(101);
      jjtn000.val = IntegerValue();
    // Add the enum into the hashtable ...
    //
    sup.addEnumDef(jjtn000.identifier, String.valueOf(jjtn000.val));
    if (jjtn000.val == 0) {
     // Get the line number ...
      //
      int lineNb= t.beginLine;
      Trace.warning(MessageHandler.getMessage("compile.w.enum",new Integer(lineNb)));
    }
      jj_consume_token(103);
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void DefinedType() throws ParseException {
                     /*@bgen(jjtree) DefinedType */
  ASTDefinedType jjtn000 = new ASTDefinedType(JJTDEFINEDTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_3(2147483647)) {
        ExternalTypeReference();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TYPEREFERENCE:
          TypeReference();
          break;
        default:
          jj_la1[39] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 101:
      case 104:
        if (jj_2_4(2147483647)) {
          SubType();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 101:
          case 104:
            IntSubType();
            break;
          default:
            jj_la1[40] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[41] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public String TypeReference() throws ParseException {
 /*@bgen(jjtree) TypeReference */
  ASTTypeReference jjtn000 = new ASTTypeReference(JJTTYPEREFERENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(TYPEREFERENCE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.symbolName= t.image;
    {if (true) return jjtn000.symbolName;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

// Similar to ASN.1 X.208
//
  final public void ExternalTypeReference() throws ParseException {
 /*@bgen(jjtree) ExternalTypeReference */
  ASTExternalTypeReference jjtn000 = new ASTExternalTypeReference(JJTEXTERNALTYPEREFERENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t1;
  Token t2;
    try {
      t1 = jj_consume_token(TYPEREFERENCE);
      jj_consume_token(106);
      t2 = jj_consume_token(TYPEREFERENCE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.moduleName = t1.image;
    jjtn000.symbolName= t2.image;
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

// Start handling values
//-----------------------
  final public ASTValue Value() throws ParseException {
                   /*@bgen(jjtree) Value */
  ASTValue jjtn000 = new ASTValue(JJTVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT:
      case DEPRECATED:
      case EMPTY:
      case ID:
      case NUMBER:
      case OPTIONAL:
      case STR:
      case IDENTIFIER:
      case TYPEREFERENCE:
        DefinedValue();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
        break;
      case FALSE:
      case TRUE:
        BooleanValue();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
        break;
      case INTEGER_LITERAL:
      case NEGATIVE_INTEGER:
        IntegerValue();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
        break;
      default:
        jj_la1[42] = jj_gen;
        if (jj_2_5(3)) {
          OidValue();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BSTRING:
          case HSTRING:
          case CSTRING:
          case 104:
            BitStringValue();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
            break;
          default:
            jj_la1[43] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void DefinedValue() throws ParseException {
 /*@bgen(jjtree) DefinedValue */
  ASTDefinedValue jjtn000 = new ASTDefinedValue(JJTDEFINEDVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT:
      case DEPRECATED:
      case EMPTY:
      case ID:
      case NUMBER:
      case OPTIONAL:
      case STR:
      case IDENTIFIER:
        jjtn000.symbolName = Identifier();
        break;
      case TYPEREFERENCE:
        t = jj_consume_token(TYPEREFERENCE);
        jj_consume_token(106);
        jjtn000.symbolName = Identifier();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.moduleName = t.image;
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

// Corresponds to  the ObjectIdentifierValue definition of ASN.1 X.208
//
  final public ASTOidValue OidValue() throws ParseException {
                         /*@bgen(jjtree) OidValue */
  ASTOidValue jjtn000 = new ASTOidValue(JJTOIDVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(104);
      label_11:
      while (true) {
        ObjectSubID();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CURRENT:
        case DEPRECATED:
        case EMPTY:
        case ID:
        case NUMBER:
        case OPTIONAL:
        case STR:
        case IDENTIFIER:
        case TYPEREFERENCE:
        case INTEGER_LITERAL:
        case NEGATIVE_INTEGER:
          ;
          break;
        default:
          jj_la1[45] = jj_gen;
          break label_11;
        }
      }
      jj_consume_token(105);
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
  {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
    throw new Error("Missing return statement in function");
  }

// Corresponds to the ObjIdComponent definition of ASN.1 X.208.
// In addition it contains the notion of DefinedValue which is defined
// as part of the NumberForm in ASN.1
// There are three different forms:
// - NamedForm (identifier)
// - NumberForm (integer)
// - NamedAndNumber form
//
  final public void ObjectSubID() throws ParseException {
                     /*@bgen(jjtree) ObjectSubID */
  ASTObjectSubID jjtn000 = new ASTObjectSubID(JJTOBJECTSUBID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case NEGATIVE_INTEGER:
        IntegerValue();
        break;
      case CURRENT:
      case DEPRECATED:
      case EMPTY:
      case ID:
      case NUMBER:
      case OPTIONAL:
      case STR:
      case IDENTIFIER:
        Identifier();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 101:
          jj_consume_token(101);
          IntegerValue();
          jj_consume_token(103);
          break;
        default:
          jj_la1[46] = jj_gen;
          ;
        }
        break;
      case TYPEREFERENCE:
        TypeReference();
        jj_consume_token(106);
        Identifier();
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public long IntegerValue() throws ParseException {
 /*@bgen(jjtree) IntegerValue */
  ASTIntegerValue jjtn000 = new ASTIntegerValue(JJTINTEGERVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        t = jj_consume_token(INTEGER_LITERAL);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    jjtn000.valStr = t.image;
    try {
      jjtn000.val=  Long.parseLong(t.image);
    } catch(java.lang.NumberFormatException e) {
      jjtn000.val=0;
    }
    {if (true) return jjtn000.val;}
        break;
      case NEGATIVE_INTEGER:
        t = jj_consume_token(NEGATIVE_INTEGER);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    jjtn000.valStr = t.image;
    try {
      jjtn000.val= Long.parseLong(t.image);
    } catch(java.lang.NumberFormatException e) {
      jjtn000.val=0;
    }
    {if (true) return jjtn000.val;}
        break;
      default:
        jj_la1[48] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public boolean BooleanValue() throws ParseException {
                         /*@bgen(jjtree) BooleanValue */
  ASTBooleanValue jjtn000 = new ASTBooleanValue(JJTBOOLEANVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
        jj_consume_token(TRUE);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    jjtn000.value= true;
    {if (true) return jjtn000.value;}
        break;
      case FALSE:
        jj_consume_token(FALSE);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    jjtn000.value= false;
    {if (true) return jjtn000.value;}
        break;
      default:
        jj_la1[49] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
    throw new Error("Missing return statement in function");
  }

  final public String BitStringValue() throws ParseException {
 /*@bgen(jjtree) BitStringValue */
  ASTBitStringValue jjtn000 = new ASTBitStringValue(JJTBITSTRINGVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  ASTNameBitList list;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BSTRING:
        t = jj_consume_token(BSTRING);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.type= BSTRING;
      jjtn000.value= t.image;
      {if (true) return jjtn000.value;}
        break;
      case HSTRING:
        t = jj_consume_token(HSTRING);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.type= HSTRING;
      jjtn000.value= t.image;
      {if (true) return jjtn000.value;}
        break;
      case CSTRING:
        t = jj_consume_token(CSTRING);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.type= CSTRING;
      jjtn000.value= t.image;
      {if (true) return jjtn000.value;}
        break;
      case 104:
        list = NameBitList();
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtn000.value = list.getDefValBITS();
      {if (true) return jjtn000.value;}
        break;
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public ASTNameBitList NameBitList() throws ParseException {
                               /*@bgen(jjtree) NameBitList */
  ASTNameBitList jjtn000 = new ASTNameBitList(JJTNAMEBITLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_6(2)) {
        jj_consume_token(104);
        Identifier();
        label_12:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[51] = jj_gen;
            break label_12;
          }
          jj_consume_token(COMMA);
          Identifier();
        }
        jj_consume_token(105);
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
  {if (true) return jjtn000;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 104:
          jj_consume_token(104);
          jj_consume_token(105);
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
  {if (true) return jjtn000;}
          break;
        default:
          jj_la1[52] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public String Identifier() throws ParseException {
 /*@bgen(jjtree) Identifier */
 ASTIdentifier jjtn000 = new ASTIdentifier(JJTIDENTIFIER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        t = jj_consume_token(IDENTIFIER);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.name = t.image;
    {if (true) return jjtn000.name;}
        break;
      case NUMBER:
        t = jj_consume_token(NUMBER);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.name = t.image;
    {if (true) return jjtn000.name;}
        break;
      case STR:
        t = jj_consume_token(STR);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.name = t.image;
    {if (true) return jjtn000.name;}
        break;
      case DEPRECATED:
        t = jj_consume_token(DEPRECATED);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.name = t.image;
    {if (true) return jjtn000.name;}
        break;
      case CURRENT:
        t = jj_consume_token(CURRENT);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.name = t.image;
    {if (true) return jjtn000.name;}
        break;
      case EMPTY:
        t = jj_consume_token(EMPTY);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.name = t.image;
    {if (true) return jjtn000.name;}
        break;
      case ID:
        t = jj_consume_token(ID);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.name = t.image;
    {if (true) return jjtn000.name;}
        break;
      case OPTIONAL:
        t = jj_consume_token(OPTIONAL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.name = t.image;
    {if (true) return jjtn000.name;}
        break;
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

// SNMPv1 or SNMPv2 stuff
//-----------------------

// Index clause
//
  final public ASTIndexTypes IndexTypes() throws ParseException {
                             /*@bgen(jjtree) IndexTypes */
  ASTIndexTypes jjtn000 = new ASTIndexTypes(JJTINDEXTYPES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(104);
      Identifier();
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[54] = jj_gen;
          break label_13;
        }
        jj_consume_token(COMMA);
        Identifier();
      }
      jj_consume_token(105);
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
   {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
    throw new Error("Missing return statement in function");
  }

// SNMPv1 specific macros
//-----------------------
  final public ObjectTypeDefinition ObjectTypeDefinitionV1() throws ParseException {
 /*@bgen(jjtree) ObjectTypeDefinitionV1 */
  ASTObjectTypeDefinitionV1 jjtn000 = new ASTObjectTypeDefinitionV1(JJTOBJECTTYPEDEFINITIONV1);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(ACCESS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RO:
        jj_consume_token(RO);
                  jjtn000.access= RO;
        break;
      case RW:
        jj_consume_token(RW);
                   jjtn000.access= RW;
        break;
      case WO:
        jj_consume_token(WO);
                   jjtn000.access= WO;
        break;
      case NA:
        jj_consume_token(NA);
                       jjtn000.access= NA;
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(STATUS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MANDATORY:
        jj_consume_token(MANDATORY);
                  jjtn000.status= MANDATORY;
        break;
      case OPTIONAL:
        jj_consume_token(OPTIONAL);
                 jjtn000.status= OPTIONAL;
        break;
      case OBSOLETE:
        jj_consume_token(OBSOLETE);
                 jjtn000.status= OBSOLETE;
        break;
      case DEPRECATED:
        jj_consume_token(DEPRECATED);
                   jjtn000.status= DEPRECATED;
        break;
      default:
        jj_la1[56] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DESCRIPTION:
        jj_consume_token(DESCRIPTION);
        t = jj_consume_token(CSTRING);
                              jjtn000.description= t.image;
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REFERENCE:
        jj_consume_token(REFERENCE);
        t = jj_consume_token(CSTRING);
                            jjtn000.reference= t.image;
        break;
      default:
        jj_la1[58] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INDEX:
        jj_consume_token(INDEX);
        jjtn000.indexNode = IndexTypes();
        break;
      default:
        jj_la1[59] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFVAL:
        jj_consume_token(DEFVAL);
        jj_consume_token(104);
        jjtn000.defValue = Value();
        jj_consume_token(105);
        break;
      default:
        jj_la1[60] = jj_gen;
        ;
      }
      jj_consume_token(ASSIGN);
      jjtn000.oidNode = OidValue();
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
  {if (true) return (ObjectTypeDefinition) jjtn000;}
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
    throw new Error("Missing return statement in function");
  }

// Trap definition ...
//
  final public void TrapType() throws ParseException {
 /*@bgen(jjtree) TrapType */
  ASTTrapType jjtn000 = new ASTTrapType(JJTTRAPTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(TRAP_TYPE);
      jj_consume_token(ENTERPRISE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT:
      case DEPRECATED:
      case EMPTY:
      case ID:
      case NUMBER:
      case OPTIONAL:
      case STR:
      case IDENTIFIER:
      case TYPEREFERENCE:
        DefinedValue();
        break;
      case 104:
        OidValue();
        break;
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLES:
        jj_consume_token(VARIABLES);
        jj_consume_token(104);
        Identifier();
        label_14:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[62] = jj_gen;
            break label_14;
          }
          jj_consume_token(COMMA);
          Identifier();
        }
        jj_consume_token(105);
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DESCRIPTION:
        jj_consume_token(DESCRIPTION);
        t = jj_consume_token(CSTRING);
                              jjtn000.description= t.image;
        break;
      default:
        jj_la1[64] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REFERENCE:
        jj_consume_token(REFERENCE);
        t = jj_consume_token(CSTRING);
                            jjtn000.reference= t.image;
        break;
      default:
        jj_la1[65] = jj_gen;
        ;
      }
      jj_consume_token(ASSIGN);
      jjtn000.value = IntegerValue();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

// SNMPv2 specific macros
//------------------------
  final public ObjectTypeDefinition ObjectTypeDefinitionV2() throws ParseException {
 /*@bgen(jjtree) ObjectTypeDefinitionV2 */
  ASTObjectTypeDefinitionV2 jjtn000 = new ASTObjectTypeDefinitionV2(JJTOBJECTTYPEDEFINITIONV2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNITS:
        jj_consume_token(UNITS);
        t = jj_consume_token(CSTRING);
                        jjtn000.description= t.image;
        break;
      default:
        jj_la1[66] = jj_gen;
        ;
      }
      jj_consume_token(MAXACCESS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case RO:
        jj_consume_token(RO);
                  jjtn000.access= RO;
        break;
      case RW:
        jj_consume_token(RW);
                   jjtn000.access= RW;
        break;
      case RC:
        jj_consume_token(RC);
                    jjtn000.access= RC;
        break;
      case NA:
        jj_consume_token(NA);
                       jjtn000.access= NA;
        break;
      case AFN:
        jj_consume_token(AFN);
                             jjtn000.access= AFN;
        break;
      default:
        jj_la1[67] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(STATUS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT:
        jj_consume_token(CURRENT);
                jjtn000.status= CURRENT;
        break;
      case OBSOLETE:
        jj_consume_token(OBSOLETE);
                 jjtn000.status= OBSOLETE;
        break;
      case DEPRECATED:
        jj_consume_token(DEPRECATED);
                   jjtn000.status= DEPRECATED;
        break;
      default:
        jj_la1[68] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DESCRIPTION:
        jj_consume_token(DESCRIPTION);
        t = jj_consume_token(CSTRING);
                              jjtn000.description= t.image;
        break;
      default:
        jj_la1[69] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REFERENCE:
        jj_consume_token(REFERENCE);
        t = jj_consume_token(CSTRING);
                            jjtn000.reference= t.image;
        break;
      default:
        jj_la1[70] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AUGMENTS:
      case INDEX:
        jjtn000.indexNode = IndexParts();
        break;
      default:
        jj_la1[71] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFVAL:
        jj_consume_token(DEFVAL);
        jj_consume_token(104);
        jjtn000.defValue = Value();
        jj_consume_token(105);
        break;
      default:
        jj_la1[72] = jj_gen;
        ;
      }
      jj_consume_token(ASSIGN);
      jjtn000.oidNode = OidValue();
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
  {if (true) return (ObjectTypeDefinition) jjtn000;}
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
    throw new Error("Missing return statement in function");
  }

// The index clause is a bit more complex in V2 than in V1.
//
  final public ASTIndexParts IndexParts() throws ParseException {
                             /*@bgen(jjtree) IndexParts */
  ASTIndexParts jjtn000 = new ASTIndexParts(JJTINDEXPARTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INDEX:
        jj_consume_token(INDEX);
           jjtn000.type= INDEX;
        IndexTypesV2();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jjtn000;}
        break;
      case AUGMENTS:
        jj_consume_token(AUGMENTS);
              jjtn000.type= AUGMENTS;
        jj_consume_token(104);
        Value();
        jj_consume_token(105);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jjtn000;}
        break;
      default:
        jj_la1[73] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public void IndexTypesV2() throws ParseException {
                      /*@bgen(jjtree) IndexTypesV2 */
  ASTIndexTypesV2 jjtn000 = new ASTIndexTypesV2(JJTINDEXTYPESV2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(104);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPLIED:
        jj_consume_token(IMPLIED);
        Identifier();
        break;
      case CURRENT:
      case DEPRECATED:
      case EMPTY:
      case ID:
      case NUMBER:
      case OPTIONAL:
      case STR:
      case IDENTIFIER:
        Identifier();
        break;
      default:
        jj_la1[74] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[75] = jj_gen;
          break label_15;
        }
        jj_consume_token(COMMA);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IMPLIED:
          jj_consume_token(IMPLIED);
          Identifier();
          break;
        case CURRENT:
        case DEPRECATED:
        case EMPTY:
        case ID:
        case NUMBER:
        case OPTIONAL:
        case STR:
        case IDENTIFIER:
          Identifier();
          break;
        default:
          jj_la1[76] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(105);
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

// We allow the module identify to be located anywhere in the
// Mib whereas an RFC states that it should be next after the
// import close ...
  final public void ModuleIdentity(ASTMib myMib, String symbolName) throws ParseException {
 /*@bgen(jjtree) ModuleIdentity */
 ASTModuleIdentity jjtn000 = new ASTModuleIdentity(JJTMODULEIDENTITY);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
 ASTOidValue oid= null;
    try {
      jj_consume_token(MODULE_IDENTITY);
      jj_consume_token(LASTUPDATE);
      t = jj_consume_token(CSTRING);
     jjtn000.lastUpdate= t.image;
      jj_consume_token(ORG);
      t = jj_consume_token(CSTRING);
     jjtn000.org = t.image;
      jj_consume_token(CONTACT);
      t = jj_consume_token(CSTRING);
     jjtn000.contact = t.image;
      jj_consume_token(DESCRIPTION);
      t = jj_consume_token(CSTRING);
     jjtn000.description= t.image;
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case REVISION:
          ;
          break;
        default:
          jj_la1[77] = jj_gen;
          break label_16;
        }
        Revision();
      }
      jj_consume_token(ASSIGN);
      oid = OidValue();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                   myMib.registerValueDef(symbolName,oid);
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void Revision() throws ParseException {
 /*@bgen(jjtree) Revision */
 ASTRevision jjtn000 = new ASTRevision(JJTREVISION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(REVISION);
      t = jj_consume_token(CSTRING);
     jjtn000.date= t.image;
      jj_consume_token(DESCRIPTION);
      t = jj_consume_token(CSTRING);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
     jjtn000.description= t.image;
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

// Textual Convention 
//-------------------
  final public void TextualConvention(ASTMib myMib) throws ParseException {
 /*@bgen(jjtree) TextualConvention */
  ASTTextualConvention jjtn000 = new ASTTextualConvention(JJTTEXTUALCONVENTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(TYPEREFERENCE);
                    jjtn000.symbolName= t.image;
      jj_consume_token(ASSIGN);
      jj_consume_token(TEXTUAL_CONVENTION);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DISPLAY:
        jj_consume_token(DISPLAY);
        t = jj_consume_token(CSTRING);
                                jjtn000.hint= t.image;
        break;
      default:
        jj_la1[78] = jj_gen;
        ;
      }
      jj_consume_token(STATUS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT:
        jj_consume_token(CURRENT);
                jjtn000.status= CURRENT;
        break;
      case OBSOLETE:
        jj_consume_token(OBSOLETE);
                 jjtn000.status= OBSOLETE;
        break;
      case DEPRECATED:
        jj_consume_token(DEPRECATED);
                   jjtn000.status= DEPRECATED;
        break;
      default:
        jj_la1[79] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(DESCRIPTION);
      t = jj_consume_token(CSTRING);
                            jjtn000.description= t.image;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REFERENCE:
        jj_consume_token(REFERENCE);
        t = jj_consume_token(CSTRING);
                            jjtn000.reference= t.image;
        break;
      default:
        jj_la1[80] = jj_gen;
        ;
      }
      jj_consume_token(SYNTAX);
      Type();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    myMib.registerSyntaxDef(jjtn000.symbolName, jjtn000);
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

// Module Compliance
//------------------
  final public void ModuleCompliance() throws ParseException {
 /*@bgen(jjtree) ModuleCompliance */
  ASTModuleCompliance jjtn000 = new ASTModuleCompliance(JJTMODULECOMPLIANCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(MODULE_COMPLIANCE);
      jj_consume_token(STATUS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT:
        jj_consume_token(CURRENT);
                jjtn000.status= CURRENT;
        break;
      case OBSOLETE:
        jj_consume_token(OBSOLETE);
                 jjtn000.status= OBSOLETE;
        break;
      case DEPRECATED:
        jj_consume_token(DEPRECATED);
                   jjtn000.status= DEPRECATED;
        break;
      default:
        jj_la1[81] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(DESCRIPTION);
      t = jj_consume_token(CSTRING);
     jjtn000.description= t.image;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REFERENCE:
        jj_consume_token(REFERENCE);
        t = jj_consume_token(CSTRING);
                            jjtn000.reference= t.image;
        break;
      default:
        jj_la1[82] = jj_gen;
        ;
      }
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case MODULE:
          ;
          break;
        default:
          jj_la1[83] = jj_gen;
          break label_17;
        }
        Module();
      }
      jj_consume_token(ASSIGN);
      jjtn000.oidNode = OidValue();
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void Module() throws ParseException {
 /*@bgen(jjtree) Module */
  ASTModule jjtn000 = new ASTModule(JJTMODULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(MODULE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TYPEREFERENCE:
        jjtn000.moduleIdentifier = ModuleIdentifier();
        break;
      default:
        jj_la1[84] = jj_gen;
        ;
      }
      jj_consume_token(MANDATGROUPS);
      jj_consume_token(104);
      Identifier();
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[85] = jj_gen;
          break label_18;
        }
        jj_consume_token(COMMA);
        Identifier();
      }
      jj_consume_token(105);
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case GROUP:
        case OBJECT:
          ;
          break;
        default:
          jj_la1[86] = jj_gen;
          break label_19;
        }
        Compliance();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Compliance() throws ParseException {
                    /*@bgen(jjtree) Compliance */
  ASTCompliance jjtn000 = new ASTCompliance(JJTCOMPLIANCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GROUP:
        ComplianceGroup();
        break;
      case OBJECT:
        Object();
        break;
      default:
        jj_la1[87] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void ComplianceGroup() throws ParseException {
 /*@bgen(jjtree) ComplianceGroup */
  ASTComplianceGroup jjtn000 = new ASTComplianceGroup(JJTCOMPLIANCEGROUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(GROUP);
      jjtn000.identifier = Identifier();
      jj_consume_token(DESCRIPTION);
      jj_consume_token(CSTRING);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void Object() throws ParseException {
                /*@bgen(jjtree) Object */
  ASTObject jjtn000 = new ASTObject(JJTOBJECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(OBJECT);
      jjtn000.identifier = Identifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SYNTAX:
        jj_consume_token(SYNTAX);
        Type();
        break;
      default:
        jj_la1[88] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WRITE_SYNTAX:
        jj_consume_token(WRITE_SYNTAX);
        Type();
        break;
      default:
        jj_la1[89] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MIN_ACCESS:
        jj_consume_token(MIN_ACCESS);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case RO:
          jj_consume_token(RO);
                    jjtn000.access= RO;
          break;
        case RW:
          jj_consume_token(RW);
                     jjtn000.access= RW;
          break;
        case RC:
          jj_consume_token(RC);
                      jjtn000.access= RC;
          break;
        case NA:
          jj_consume_token(NA);
                         jjtn000.access= NA;
          break;
        case AFN:
          jj_consume_token(AFN);
                               jjtn000.access= AFN;
          break;
        default:
          jj_la1[90] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[91] = jj_gen;
        ;
      }
      jj_consume_token(DESCRIPTION);
      jj_consume_token(CSTRING);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void ObjectIdentity(ASTMib myMib, String symbolName) throws ParseException {
 /*@bgen(jjtree) ObjectIdentity */
  ASTObjectIdentity jjtn000 = new ASTObjectIdentity(JJTOBJECTIDENTITY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(OBJECT_IDENTITY);
      jj_consume_token(STATUS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT:
        jj_consume_token(CURRENT);
                jjtn000.status= CURRENT;
        break;
      case OBSOLETE:
        jj_consume_token(OBSOLETE);
                 jjtn000.status= OBSOLETE;
        break;
      case DEPRECATED:
        jj_consume_token(DEPRECATED);
                   jjtn000.status= DEPRECATED;
        break;
      default:
        jj_la1[92] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(DESCRIPTION);
      t = jj_consume_token(CSTRING);
                            jjtn000.description= t.image;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REFERENCE:
        jj_consume_token(REFERENCE);
        t = jj_consume_token(CSTRING);
                            jjtn000.reference= t.image;
        break;
      default:
        jj_la1[93] = jj_gen;
        ;
      }
      jj_consume_token(ASSIGN);
      jjtn000.oid = OidValue();
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
    myMib.registerObjectIdentity(symbolName, jjtn000);
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void NotificationType(ASTMib myMib, String symbolName) throws ParseException {
 /*@bgen(jjtree) NotificationType */
  ASTNotificationType jjtn000 = new ASTNotificationType(JJTNOTIFICATIONTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(NOTIFICATION_TYPE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJECTS:
        jj_consume_token(OBJECTS);
        jjtn000.objectParts = ObjectsPart();
        break;
      default:
        jj_la1[94] = jj_gen;
        ;
      }
      jj_consume_token(STATUS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT:
        jj_consume_token(CURRENT);
                jjtn000.status= CURRENT;
        break;
      case OBSOLETE:
        jj_consume_token(OBSOLETE);
                 jjtn000.status= OBSOLETE;
        break;
      case DEPRECATED:
        jj_consume_token(DEPRECATED);
                   jjtn000.status= DEPRECATED;
        break;
      default:
        jj_la1[95] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(DESCRIPTION);
      t = jj_consume_token(CSTRING);
                            jjtn000.description= t.image;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REFERENCE:
        jj_consume_token(REFERENCE);
        t = jj_consume_token(CSTRING);
                            jjtn000.reference= t.image;
        break;
      default:
        jj_la1[96] = jj_gen;
        ;
      }
      jj_consume_token(ASSIGN);
      jjtn000.oid = OidValue();
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
        myMib.registerNotificationType(symbolName,jjtn000);
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public Node ObjectsPart() throws ParseException {
                     /*@bgen(jjtree) ObjectsPart */
  ASTObjectsPart jjtn000 = new ASTObjectsPart(JJTOBJECTSPART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(104);
      Identifier();
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[97] = jj_gen;
          break label_20;
        }
        jj_consume_token(COMMA);
        Identifier();
      }
      jj_consume_token(105);
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
     {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
    throw new Error("Missing return statement in function");
  }

// Handle the OBJECT-GROUP macro...
//---------------------------------
  final public void ObjectGroup(ASTMib myMib, String symbolName) throws ParseException {
 /*@bgen(jjtree) ObjectGroup */
  ASTObjectGroup jjtn000 = new ASTObjectGroup(JJTOBJECTGROUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(OBJECT_GROUP);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OBJECTS:
        jj_consume_token(OBJECTS);
        ObjectsPart();
        break;
      default:
        jj_la1[98] = jj_gen;
        ;
      }
      jj_consume_token(STATUS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT:
        jj_consume_token(CURRENT);
                jjtn000.status= CURRENT;
        break;
      case OBSOLETE:
        jj_consume_token(OBSOLETE);
                 jjtn000.status= OBSOLETE;
        break;
      case DEPRECATED:
        jj_consume_token(DEPRECATED);
                   jjtn000.status= DEPRECATED;
        break;
      default:
        jj_la1[99] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(DESCRIPTION);
      t = jj_consume_token(CSTRING);
                            jjtn000.description= t.image;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REFERENCE:
        jj_consume_token(REFERENCE);
        t = jj_consume_token(CSTRING);
                            jjtn000.reference= t.image;
        break;
      default:
        jj_la1[100] = jj_gen;
        ;
      }
      jj_consume_token(ASSIGN);
      jjtn000.oid = OidValue();
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
    myMib.registerObjectGroup(symbolName, jjtn000);
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

// Handle the Notification Group macro
//------------------------------------
  final public void NotificationGroup(ASTMib myMib, String symbolName) throws ParseException {
 /*@bgen(jjtree) NotificationGroup */
  ASTNotificationGroup jjtn000 = new ASTNotificationGroup(JJTNOTIFICATIONGROUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      jj_consume_token(NOTIFICATION_GROUP);
      jj_consume_token(NOTIFICATIONS);
      ObjectsPart();
      jj_consume_token(STATUS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CURRENT:
        jj_consume_token(CURRENT);
                jjtn000.status= CURRENT;
        break;
      case OBSOLETE:
        jj_consume_token(OBSOLETE);
                 jjtn000.status= OBSOLETE;
        break;
      case DEPRECATED:
        jj_consume_token(DEPRECATED);
                   jjtn000.status= DEPRECATED;
        break;
      default:
        jj_la1[101] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(DESCRIPTION);
      t = jj_consume_token(CSTRING);
                            jjtn000.description= t.image;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REFERENCE:
        jj_consume_token(REFERENCE);
        t = jj_consume_token(CSTRING);
                            jjtn000.reference= t.image;
        break;
      default:
        jj_la1[102] = jj_gen;
        ;
      }
      jj_consume_token(ASSIGN);
      jjtn000.oid = OidValue();
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
    myMib.registerNotifGroup(symbolName, jjtn000);
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

// Hack to simplify parsing ...
//-----------------------------
  final public String Reserved() throws ParseException {
 /*@bgen(jjtree) Reserved */
  ASTReserved jjtn000 = new ASTReserved(JJTRESERVED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEXTUAL_CONVENTION:
        t = jj_consume_token(TEXTUAL_CONVENTION);
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                         jjtn000.type= TEXTUAL_CONVENTION; {if (true) return t.image;}
        break;
      case OBJECT_TYPE:
        t = jj_consume_token(OBJECT_TYPE);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                  jjtn000.type= OBJECT_TYPE; {if (true) return t.image;}
        break;
      case OBJECT_IDENTITY:
        t = jj_consume_token(OBJECT_IDENTITY);
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                     jjtn000.type= OBJECT_IDENTITY;{if (true) return t.image;}
        break;
      case MODULE_IDENTITY:
        t = jj_consume_token(MODULE_IDENTITY);
                      jjtree.closeNodeScope(jjtn000, true);
                      jjtc000 = false;
                     jjtn000.type= MODULE_IDENTITY;{if (true) return t.image;}
        break;
      case MODULE_COMPLIANCE:
        t = jj_consume_token(MODULE_COMPLIANCE);
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                       jjtn000.type= MODULE_COMPLIANCE;{if (true) return t.image;}
        break;
      case AGENT:
        t = jj_consume_token(AGENT);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
           jjtn000.type= AGENT;{if (true) return t.image;}
        break;
      case TRAP_TYPE:
        t = jj_consume_token(TRAP_TYPE);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
               jjtn000.type= TRAP_TYPE;{if (true) return t.image;}
        break;
      case NOTIFICATION_TYPE:
        t = jj_consume_token(NOTIFICATION_TYPE);
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                      jjtn000.type= NOTIFICATION_TYPE;{if (true) return t.image;}
        break;
      case OBJECT_GROUP:
        t = jj_consume_token(OBJECT_GROUP);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                 jjtn000.type= OBJECT_GROUP;{if (true) return t.image;}
        break;
      case NOTIFICATION_GROUP:
        t = jj_consume_token(NOTIFICATION_GROUP);
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                       jjtn000.type= NOTIFICATION_GROUP;{if (true) return t.image;}
        break;
      case TYPE:
        t = jj_consume_token(TYPE);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
          jjtn000.type= TYPE;{if (true) return t.image;}
        break;
      case SYNTAX:
        t = jj_consume_token(SYNTAX);
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
            jjtn000.type= SYNTAX;{if (true) return t.image;}
        break;
      default:
        jj_la1[103] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
    throw new Error("Missing return statement in function");
  }

// Simple handling of macro. Just parse the XXX stuff !
//-------------------------
  final public void MacroDefinition() throws ParseException {
                         /*@bgen(jjtree) MacroDefinition */
  ASTMacroDefinition jjtn000 = new ASTMacroDefinition(JJTMACRODEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TYPEREFERENCE:
        jjtn000.symbolName = TypeReference();
        break;
      case AGENT:
      case MODULE_COMPLIANCE:
      case MODULE_IDENTITY:
      case NOTIFICATION_GROUP:
      case NOTIFICATION_TYPE:
      case OBJECT_IDENTITY:
      case OBJECT_GROUP:
      case OBJECT_TYPE:
      case SYNTAX:
      case TEXTUAL_CONVENTION:
      case TRAP_TYPE:
      case TYPE:
        jjtn000.symbolName = Reserved();
        break;
      default:
        jj_la1[104] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(MACRO);
      jj_consume_token(ASSIGN);
      jj_consume_token(BEGIN);
      MacroBody();
      jj_consume_token(END);
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void MacroBody() throws ParseException {
                   /*@bgen(jjtree) MacroBody */
  ASTMacroBody jjtn000 = new ASTMacroBody(JJTMACROBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(TYPE);
      jj_consume_token(NOTATION);
      jj_consume_token(ASSIGN);
      MacroAlternativeList();
      jj_consume_token(VALUE);
      jj_consume_token(NOTATION);
      jj_consume_token(ASSIGN);
      MacroAlternativeList();
      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TYPEREFERENCE:
          ;
          break;
        default:
          jj_la1[105] = jj_gen;
          break label_21;
        }
        TypeReference();
        jj_consume_token(ASSIGN);
        MacroAlternativeList();
      }
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void MacroAlternativeList() throws ParseException {
                              /*@bgen(jjtree) MacroAlternativeList */
  ASTMacroAlternativeList jjtn000 = new ASTMacroAlternativeList(JJTMACROALTERNATIVELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      MacroAlternative();
      label_22:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 102:
          ;
          break;
        default:
          jj_la1[106] = jj_gen;
          break label_22;
        }
        jj_consume_token(102);
        MacroAlternative();
      }
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void MacroAlternative() throws ParseException {
                          /*@bgen(jjtree) MacroAlternative */
  ASTMacroAlternative jjtn000 = new ASTMacroAlternative(JJTMACROALTERNATIVE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_23:
      while (true) {
        SymbolElement();
        if (jj_2_7(1)) {
          ;
        } else {
          break label_23;
        }
      }
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void SymbolElement() throws ParseException {
                       /*@bgen(jjtree) SymbolElement */
  ASTSymbolElement jjtn000 = new ASTSymbolElement(JJTSYMBOLELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      if (jj_2_8(1)) {
        SymbolDefn();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 107:
          jj_consume_token(107);
          EmbeddedDefinitions();
          jj_consume_token(108);
          break;
        default:
          jj_la1[107] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  final public void SymbolDefn() throws ParseException {
 /*@bgen(jjtree) SymbolDefn */
  ASTSymbolDefn jjtn000 = new ASTSymbolDefn(JJTSYMBOLDEFN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STR:
        jj_consume_token(STR);
        break;
      case ID:
        jj_consume_token(ID);
        break;
      case NUMBER:
        jj_consume_token(NUMBER);
        break;
      case EMPTY:
        jj_consume_token(EMPTY);
        break;
      case CSTRING:
        jj_consume_token(CSTRING);
        break;
      case VAL:
        jj_consume_token(VAL);
        jj_consume_token(101);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VALUE:
          jj_consume_token(VALUE);
          MacroType();
          break;
        case TYPEREFERENCE:
          TypeReference();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case BIT:
          case BITS:
          case CHOICE:
          case INTEGER:
          case NULL:
          case OBJECT:
          case OCTET:
          case SEQUENCE:
          case TYPEREFERENCE:
          case 99:
            Type();
            break;
          default:
            jj_la1[108] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[109] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(103);
        break;
      case TYPE_MACRO:
        jj_consume_token(TYPE_MACRO);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 101:
          jj_consume_token(101);
          MacroType();
          jj_consume_token(103);
          break;
        default:
          jj_la1[110] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[111] = jj_gen;
        if (jj_2_9(2147483647) && (getToken(2).kind != ASSIGN)) {
          TypeReference();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            t = jj_consume_token(IDENTIFIER);
            break;
          default:
            jj_la1[112] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void EmbeddedDefinitions() throws ParseException {
                             /*@bgen(jjtree) EmbeddedDefinitions */
  ASTEmbeddedDefinitions jjtn000 = new ASTEmbeddedDefinitions(JJTEMBEDDEDDEFINITIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TYPEREFERENCE:
        LocalTypeAssignment();
        break;
      case CURRENT:
      case DEPRECATED:
      case EMPTY:
      case ID:
      case NUMBER:
      case OPTIONAL:
      case STR:
      case IDENTIFIER:
        LocalValueAssignment();
        break;
      default:
        jj_la1[113] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void LocalTypeAssignment() throws ParseException {
                             /*@bgen(jjtree) LocalTypeAssignment */
  ASTLocalTypeAssignment jjtn000 = new ASTLocalTypeAssignment(JJTLOCALTYPEASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      TypeReference();
      jj_consume_token(ASSIGN);
      MacroType();
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void LocalValueAssignment() throws ParseException {
                              /*@bgen(jjtree) LocalValueAssignment */
  ASTLocalValueAssignment jjtn000 = new ASTLocalValueAssignment(JJTLOCALVALUEASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Identifier();
      MacroType();
      jj_consume_token(ASSIGN);
      Value();
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  final public void MacroType() throws ParseException {
                   /*@bgen(jjtree) MacroType */
  ASTMacroType jjtn000 = new ASTMacroType(JJTMACROTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_24:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AGENT:
        case MODULE_COMPLIANCE:
        case MODULE_IDENTITY:
        case NOTIFICATION_GROUP:
        case NOTIFICATION_TYPE:
        case OBJECT_IDENTITY:
        case OBJECT_GROUP:
        case OBJECT_TYPE:
        case SYNTAX:
        case TEXTUAL_CONVENTION:
        case TRAP_TYPE:
        case TYPE:
          Reserved();
          break;
        case BIT:
        case BITS:
        case CHOICE:
        case INTEGER:
        case NULL:
        case OBJECT:
        case OCTET:
        case SEQUENCE:
        case TYPEREFERENCE:
        case 99:
          Type();
          break;
        default:
          jj_la1[114] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AGENT:
        case BIT:
        case BITS:
        case CHOICE:
        case INTEGER:
        case MODULE_COMPLIANCE:
        case MODULE_IDENTITY:
        case NOTIFICATION_GROUP:
        case NOTIFICATION_TYPE:
        case NULL:
        case OBJECT:
        case OBJECT_IDENTITY:
        case OBJECT_GROUP:
        case OBJECT_TYPE:
        case OCTET:
        case SEQUENCE:
        case SYNTAX:
        case TEXTUAL_CONVENTION:
        case TRAP_TYPE:
        case TYPE:
        case TYPEREFERENCE:
        case 99:
          ;
          break;
        default:
          jj_la1[115] = jj_gen;
          break label_24;
        }
      }
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

// Finally handle the AGENT-CAPABILITIES
//--------------------------------------
  final public void AgentCapabilities() throws ParseException {
    jj_consume_token(AGENT);
    skip_agentCapabilitiesDef();
    OidValue();
  }

  final public void skip_agentCapabilitiesDef() throws ParseException {
  Token tok;
  tok= getNextToken();
  while (tok.kind != EOF) {
    if (tok.kind == ASSIGN) {
       break;
    }
    tok= getNextToken();
  }
  if (tok.kind == EOF) {
    String eol = System.getProperty("line.separator", "\n");
    {if (true) throw new ParseException(MessageHandler.getMessage("parse.exception.msg.pos",
      "<EOF>",
      new Integer(tok.beginLine),
      new Integer(tok.beginColumn)) +
      eol + "    " +
      MessageHandler.getMessage("parse.exception.msg.exp", "::="));}
  }
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_3R_44() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_45() {
    if (jj_3R_48()) return true;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_scan_token(104)) return true;
    if (jj_3R_27()) return true;
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_3R_44()) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_3R_30()) return true;
    return false;
  }

  final private boolean jj_3R_26() {
    if (jj_scan_token(104)) return true;
    Token xsp;
    if (jj_3R_31()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_31()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(105)) return true;
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_3R_30()) return true;
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_scan_token(TYPE_MACRO)) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(TYPEREFERENCE)) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_scan_token(VAL)) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(TYPEREFERENCE)) return true;
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_scan_token(TEXTUAL_CONVENTION)) return true;
    return false;
  }

  final private boolean jj_3R_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(72)) {
    jj_scanpos = xsp;
    if (jj_scan_token(32)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) {
    jj_scanpos = xsp;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = getToken(2).kind != ASSIGN;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_26()) return true;
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_scan_token(107)) return true;
    return false;
  }

  final private boolean jj_3R_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) return true;
    }
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_3R_29()) return true;
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_scan_token(OPTIONAL)) return true;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_28()) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_scan_token(ID)) return true;
    return false;
  }

  final private boolean jj_3R_25() {
    if (jj_scan_token(TYPEREFERENCE)) return true;
    if (jj_scan_token(106)) return true;
    if (jj_scan_token(TYPEREFERENCE)) return true;
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_scan_token(EMPTY)) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    if (jj_scan_token(CURRENT)) return true;
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_scan_token(NEGATIVE_INTEGER)) return true;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_scan_token(DEPRECATED)) return true;
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_scan_token(TYPEREFERENCE)) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    if (jj_scan_token(STR)) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_scan_token(101)) return true;
    if (jj_scan_token(SIZE)) return true;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_scan_token(101)) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) return true;
    }
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_scan_token(NUMBER)) return true;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_25()) return true;
    return false;
  }

  final private boolean jj_3R_32() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_27() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_3R_30()) return true;
    if (jj_scan_token(106)) return true;
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_3R_27()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) jj_scanpos = xsp;
    return false;
  }

  public ParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[116];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x8000000,0x0,0x920100,0xe100,0x920000,0x100,0x40,0x920100,0x920100,0x0,0x920100,0x0,0xe000,0x0,0x0,0x0,0x0,0xe000,0x200,0x200,0x4000000,0x4000000,0x0,0x0,0x920000,0x0,0x920000,0x0,0x920000,0x0,0x920000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10920000,0x0,0x920000,0x920000,0x0,0x920000,0x0,0x10000000,0x0,0x0,0x0,0x920000,0x0,0x0,0x100000,0x200000,0x0,0x0,0x80000,0x920000,0x0,0x0,0x200000,0x0,0x0,0x80,0x120000,0x200000,0x0,0x800,0x80000,0x800,0x920000,0x0,0x920000,0x0,0x400000,0x120000,0x0,0x120000,0x0,0x0,0x0,0x0,0x40000000,0x40000000,0x0,0x0,0x80,0x0,0x120000,0x0,0x0,0x120000,0x0,0x0,0x0,0x120000,0x0,0x120000,0x0,0x100,0x100,0x0,0x0,0x0,0xe000,0x0,0x0,0x800000,0x0,0x920000,0xe100,0xe100,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x8,0x472c6001,0x175c6020,0x40200001,0x70c6000,0x400,0x472c6001,0x472c6001,0x0,0x472c6001,0x0,0x10500020,0x0,0x0,0x0,0x0,0x10500020,0x0,0x0,0x2,0x2,0x0,0x0,0x40200001,0x0,0x40200001,0x20000000,0x40200001,0x0,0x40200001,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40200001,0x0,0x40200001,0x40200001,0x0,0x40200001,0x0,0x0,0x0,0x0,0x0,0x40200001,0x0,0x8000,0x48000200,0x0,0x0,0x10,0x0,0x40200001,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000000,0x0,0x0,0x10,0x0,0x10,0x40200005,0x0,0x40200005,0x0,0x0,0x8000000,0x0,0x8000000,0x0,0x1000,0x0,0x0,0x400000,0x400000,0x0,0x0,0x8000,0x800,0x8000000,0x0,0x800000,0x8000000,0x0,0x0,0x800000,0x8000000,0x0,0x8000000,0x0,0x70c6000,0x70c6000,0x0,0x0,0x0,0x10500020,0x0,0x0,0x200001,0x0,0x40200001,0x175c6020,0x175c6020,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x1000000,0x0,0x0,0x0,0x1805d00,0x1001020,0x800100,0x1005c00,0x10000,0x1805d00,0x1805d00,0x0,0x1805d00,0x0,0x1000020,0x0,0x0,0x0,0x0,0x20,0x20000,0x20000,0x0,0x0,0x0,0x78000040,0x800100,0x0,0x800100,0x0,0x800100,0x0,0x800100,0x0,0x0,0x0,0x0,0x0,0x78000000,0x1000000,0x0,0x0,0x19802100,0xe0000000,0x1800100,0x19800100,0x0,0x19800100,0x18000000,0x2000,0xe0000000,0x0,0x0,0x800100,0x0,0x200018,0x0,0x0,0x1,0x0,0x0,0x1800100,0x0,0x100000,0x0,0x1,0x10000,0x1c,0x0,0x0,0x1,0x0,0x0,0x0,0x800100,0x0,0x800100,0x2,0x0,0x0,0x1,0x0,0x1,0x0,0x1000000,0x0,0x0,0x0,0x400,0x400000,0x1c,0x0,0x0,0x1,0x0,0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x1,0x5c00,0x1005c00,0x1000000,0x0,0x0,0x1000020,0x1080000,0x0,0x80048100,0x800000,0x1800100,0x1005c20,0x1005c20,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x0,0x100,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x8,0x8,0x120,0x20,0x100,0x100,0x0,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x2,0x0,0x100,0x0,0x2,0x0,0x2,0x2,0x40,0x120,0x4,0x0,0x0,0x120,0x120,0x0,0x100,0x0,0x0,0x20,0x0,0x0,0x0,0x100,0x2,0x100,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x800,0x8,0x0,0x20,0x0,0x0,0x0,0x8,0x8,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[9];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public Parser(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 116; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 116; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public Parser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 116; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 116; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 116; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 116; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[109];
    for (int i = 0; i < 109; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 116; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 109; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 9; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
