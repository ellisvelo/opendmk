/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*//*
 * @(#)file      Parser.jjt
 * @(#)author    Sun Microsystems, Inc.
 * @(#)version   4.4
 * @(#)date      01/01/17
 *
 * 
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 * 
 * Copyright (c) 2007 Sun Microsystems, Inc. All Rights Reserved.
 * 
 * The contents of this file are subject to the terms of either the GNU General
 * Public License Version 2 only ("GPL") or the Common Development and
 * Distribution License("CDDL")(collectively, the "License"). You may not use
 * this file except in compliance with the License. You can obtain a copy of the
 * License at http://opendmk.dev.java.net/legal_notices/licenses.txt or in the 
 * LEGAL_NOTICES folder that accompanied this code. See the License for the 
 * specific language governing permissions and limitations under the License.
 * 
 * When distributing the software, include this License Header Notice in each
 * file and include the License file found at
 *     http://opendmk.dev.java.net/legal_notices/licenses.txt
 * or in the LEGAL_NOTICES folder that accompanied this code.
 * Sun designates this particular file as subject to the "Classpath" exception
 * as provided by Sun in the GPL Version 2 section of the License file that
 * accompanied this code.
 * 
 * If applicable, add the following below the License Header, with the fields
 * enclosed by brackets [] replaced by your own identifying information:
 * 
 *       "Portions Copyrighted [year] [name of copyright owner]"
 * 
 * Contributor(s):
 * 
 * If you wish your version of this file to be governed by only the CDDL or
 * only the GPL Version 2, indicate your decision by adding
 * 
 *       "[Contributor] elects to include this software in this distribution
 *        under the [CDDL or GPL Version 2] license."
 * 
 * If you don't indicate a single choice of license, a recipient has the option
 * to distribute your version of this file under either the CDDL or the GPL
 * Version 2, or to extend the choice of license to its licensees as provided
 * above. However, if you add GPL Version 2 code and therefore, elected the
 * GPL Version 2 license, then the option applies only if the new code is made
 * subject to such option by the copyright holder.
 * 
 *
 */

options {              
  STATIC=false;                                                                  
}


PARSER_BEGIN(Parser)

package com.sun.management.snmp.uacl;

import java.io.*;

public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/
}

PARSER_END(Parser)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"--" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>

}



/* RESERVED WORDS AND LITERALS */

TOKEN : 
{
  <ACCESS: "access">
| <ACL: "acl">
| <ASSIGN: "=">
| <CONTEXTNAMES: "context-names">
| <USERS: "users">
| <LBRACE: "{">
| <RANGE: "-">
| <RBRACE: "}">
| <RO: "read-only">
| <RW: "read-write">
| <SECURITYLEVEL: "security-level">
| <NOAUTHNOPRIV: "noAuthNoPriv">
| <AUTHNOPRIV: "authNoPriv">
| <AUTHPRIV: "authPriv">
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|      
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
}
 
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: (<LETTER> (<SEPARATOR>|<LETTER>|<DIGIT>)*) | <ANY_USER> >
|
  < #LETTER: ["a"-"z","A"-"Z"] >
|
  < #SEPARATOR: ["-", "_"] >
|
  < #DIGIT: ["0"-"9"] >
|
  < #ANY_USER: ["*"] >
|
 <CSTRING: "\"" (~["\""])* "\"">
}

 

TOKEN: /* SEPARATOR */
{
  < COMMA: "," >
| < DOT: "." >
| < MARK: "!" >
}

// A file can contain several acl definitions
//
JDMSecurityDefs SecurityDefs()  : {/*@bgen(jjtree) SecurityDefs */
  JDMSecurityDefs jjtn000 = new JDMSecurityDefs(JJTSECURITYDEFS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SecurityDefs */
  try {
/*@egen*/
  [AclBlock()]
  <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void AclBlock(): {/*@bgen(jjtree) AclBlock */
  JDMAclBlock jjtn000 = new JDMAclBlock(JJTACLBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AclBlock */
try {
/*@egen*/
"acl" "=" "{" (AclItem())+ "}"/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

void AclItem(): {/*@bgen(jjtree) AclItem */
  JDMAclItem jjtn000 = new JDMAclItem(JJTACLITEM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AclItem */
try {
/*@egen*/
"{" jjtn000.com= ContextNames() jjtn000.access= Access() jjtn000.lev= SecurityLevel() Users() "}"/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

JDMContextNames ContextNames(): {/*@bgen(jjtree) ContextNames */
  JDMContextNames jjtn000 = new JDMContextNames(JJTCONTEXTNAMES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ContextNames */
try {
/*@egen*/
"context-names" "=" ContextName() ( "," ContextName())*/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/

{return jjtn000;}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/

}

void ContextName(): 
{/*@bgen(jjtree) ContextName */
  JDMContextName jjtn000 = new JDMContextName(JJTCONTEXTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) ContextName */
try {
/*@egen*/
t=<IDENTIFIER>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ {jjtn000.contextName= t.image;}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

JDMUsers Users(): {/*@bgen(jjtree) Users */
  JDMUsers jjtn000 = new JDMUsers(JJTUSERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Users */
try {
/*@egen*/
"users" "=" User() ( "," User())*/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/

{return jjtn000;}/*@bgen(jjtree)*/
} catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    throw (RuntimeException)jjte000;
  }
  if (jjte000 instanceof ParseException) {
    throw (ParseException)jjte000;
  }
  throw (Error)jjte000;
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/

}

void User(): 
{/*@bgen(jjtree) User */
  JDMUser jjtn000 = new JDMUser(JJTUSER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) User */
try {
/*@egen*/
t=<IDENTIFIER>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ {jjtn000.userName= t.image;}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

JDMAccess Access(): {/*@bgen(jjtree) Access */
  JDMAccess jjtn000 = new JDMAccess(JJTACCESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Access */
try {
/*@egen*/
"access" "=" ( <RO> {jjtn000.access= RO;}
              |
               <RW> {jjtn000.access= RW;}
             )/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{return jjtn000;}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

JDMSecurityLevel SecurityLevel(): {/*@bgen(jjtree) SecurityLevel */
  JDMSecurityLevel jjtn000 = new JDMSecurityLevel(JJTSECURITYLEVEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SecurityLevel */
try {
/*@egen*/
"security-level" "=" ( <NOAUTHNOPRIV> {jjtn000.securityLevel = 0;}
	      |	
		<AUTHNOPRIV> {jjtn000.securityLevel = 1;}
	      |
		<AUTHPRIV> {jjtn000.securityLevel = 3;}
             )/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/
{return jjtn000;}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}
